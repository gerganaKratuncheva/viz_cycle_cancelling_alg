<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="This applet demonstrates the Cycle Cancelling algorithm to find a minmum cost flow" />
    <meta name="keywords" content="Cycle, Cancelling, minimum cost flow, algorithm, TUM, Technische Universität München, Applet">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="author" content="Quirin Fischer">

<!--     the whole page layout style -->
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />

    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
 <!--   <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/smoothness/jquery-ui.css"> -->

 <!--     MathJax, used in the more tab in pseudocode -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>

<!-- LOCAL -->

    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <link type="text/css" href="../library/css/mmenu/jquery.mmenu.all.css" rel="stylesheet" />
    <script type="text/javascript" src="../library/js/mmenu/jquery.mmenu.min.all.js"></script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=en"></script>
    <script src="../library/js/d3/d3.js"></script>

<!-- CDN
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <link type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jQuery.mmenu/5.3.4/css/jquery.mmenu.all.min.css" rel="stylesheet" />
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jQuery.mmenu/5.3.4/js/jquery.mmenu.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=en"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
-->
<!--     Adrians d3 related library code -->
    <script src="../library-d3-svg/js/Graph.js"></script>
    <script src="../library-d3-svg/js/GraphDrawer.js"></script>
    <script src="../library-d3-svg/js/GraphEditor.js"></script>
    <script src="../library-d3-svg/js/Logger.js"></script>
    <script src="../library-d3-svg/js/Tab.js"></script>
    <script src="../library-d3-svg/js/AlgorithmTab.js"></script>
    <script src="../library-d3-svg/js/GraphEditorTab.js"></script>
    <script src="../library-d3-svg/js/siteAnimation.js"></script>

	
    <!-- lNG -->
    <script src="../library/js/lang.js" type="text/javascript"></script>
    <script src="../library/js/utilities.js" type="text/javascript"></script>

	
    <script src="js/ExerciseTab1.js" ></script>
    <script src="js/Exercise1.js"></script>
	<script src="js/ExerciseTab2.js"></script>
	<script src="js/Exercise2.js"></script>
	
	
    <link rel="stylesheet" type="text/css" href="../library-d3-svg/css/graph-style.css" />
    <link rel="stylesheet" type="text/css" href="../library-d3-svg/css/style.css" />

<!--     Files used only for this applet -->
    <script src="js/siteLayout.js" type="text/javascript"></script>
    <script src="js/CycleCancellingAlgorithm.js" type="text/javascript"></script>


    <title>Cycle Cancelling Algorithms For Min-Cost-Flow </title>
</head>
<body>
<!-- svg definitons -->
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xlink="http://www.w3.org/1999/xlink">
      <defs>
        <marker id="arrowhead2" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-red" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(196, 7, 27)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-lightRed" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(240, 128, 128)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-green" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(115, 183, 141)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>
      </defs>
    </svg>
    <noscript>
        <div class="ui-widget">
            <div class="ui-state-error ui-corner-all" style="padding: .7em;">
                <div class="ui-icon ui-icon-alert errorIcon"></div>
                <strong>Please activate Javascript!</strong>
                <ul style="margin: 0px;">
                    <li>
                        This website needs Javascript in order to be displayed properly.
                    </li>
                    <li>
                        Javascript is currently deactivated in your browser. A manual for the activation of Javascript can be found <a href="http://www.enable-javascript.com/">here</a>.
                    </li>
                </ul>
            </div>
        </div>
    </noscript>
    <script>
        $(function() {
            initializeSiteLayout(CycleCancellingAlgorithm);

        });
		<!--LNG.setLanguage('en');-->
        $(document).ready(function() {
            $("#menu").mmenu({
               "navbar": {
                  "title": "Übersicht"
               },
               "offCanvas": {
                  "zposition": "front"
               },
               "counters": true,
               "slidingSubmenus": true,
               "classes": "mm-light",
            });
         });
    </script>
    <a id="menu_link" href="#menu"></a>
    <nav id="menu">
        <ul>
            <li>
                <a style="white-space:pre-line" href="http://www-m9.ma.tum.de/Allgemeines/GraphAlgorithmenEn">
                <img src="../library/img/logo_ohne.png" alt="Overview Graph Algorithms">
                Graph Algorithms Landing Page</a>
            </li>
            <li><span>Shortest Path Algorithms</span>
                <ul>
                   <li><a href="../spp-dijkstra/index_en.html">Dijkstra's Algorithm</a></li>
                   <li><a href="../spp-a-star/index_en.html">A* Algorithm</a></li>
                   <li><a href="../spp-bellman-ford/index_en.html">Bellman-Ford Algorithm</a></li>
                   <li><a href="../spp-floyd-warshall/index_en.html">Floyd-Warshall Algorithm</a></li>
                   <!--<li><a href="../spprc-label-setting/index_en.html">Label-Setting Algorithm</a></li>-->
                </ul>
            </li>
            <li><span>Spanning Tree Algorithms</span>
                <ul>
                   <li><a href="../mst-prim/index_en.html">Prim's Algorithm</a></li>
                   <li><a href="../mst-kruskal/index_en.html">Kruskal's Algorithm</a></li>
                </ul>
            </li>
            <li><span>Flow Algorithms</span>
                <ul>
                   <li><a href="../flow-ford-fulkerson/index_en.html">Ford-Fulkerson Algorithm</a></li>
                   <li class="Selected"><a href="../flow-cycle-cancelling/index_en.html">Cycle-Cancelling Algorithm</a></li>
                   <!--<li><a href="../flow-push-relabel/index_en.html">Push-Relabel Algorithm</a></li>-->
                </ul>
            </li>
            <li><span>Matching Algorithms</span>
                <ul>
                   <li><a href="../matchings-hopcroft-karp/index_en.html">Hopcroft-Karp Algorithm</a></li>
                   <li><a href="../matchings-hungarian-method/index_en.html">Hungarian Method</a></li>
                   <li><a href="../matchings-blossom-algorithm/index_en.html">Blossom Algorithm</a></li>
                </ul>
            </li>
            <li><span>Euler Tours and Chinese Postman Problem</span>
                <ul>
                   <li><a href="../hierholzer/index_en.html">Hierholzer's Algorithm</a></li>
                   <li><a href="../directed-chinese-postman/index_en.html">Chinese Postman Problem</a></li>
                </ul>
            </li>
        </ul>
    </nav>
    <!--<div>-->
    <header>
        <img src="img/title.svg" alt="A maximum flow"></img>
        <span class="adrianheader">Cycle Cancelling Algorithm</span>
        <img style="position:absolute; right:0px" src="../library/img/TUMLogo.png" alt="Technische Universität München">
    </header>

<!--     <svg height="0px" widht ="0px">
        <defs>
        <marker id="arrowhead2" refX="12" refY="2" markerWidth="12" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker>
        </defs>
    </svg> -->
    <div id="tabs">
        <ul>
		    <!-- Define your tabs -->
            <li><a href="#tab_te"><span>Introduction</span></a></li>
            <li><a href="#tab_tg"><span>Create a graph</span></a></li>
            <li><a href="#tab_ta"><span>Run the algorithm</span></a></li>
            <li><a href="#tab_ti"><span>Description of the algorithm</span></a></li>
            <li><a href="#tab_tf1"><span>Exercise 1</span></a></li>
            <li><a href="#tab_tf2"><span>Exercise 2</span></a></li>
            <li><a href="#tab_tw"><span>More</span></a></li>
        </ul>

        <!-- TAB Einführung -->
        <div id="tab_te">
            <div id="te_div_Einfuehrungstext">

                <div id="te_div_beispiel1Container">
                <div id="svgtest"></div>
                <img id="te_img_beispiel1" src="img/ahuja.svg" alt="ahuja">
<!--                 <object data="img/ahuja.svg" type="image/svg+xml" width="300px"> -->
<!--                 type="image/svg+xml"-->

<!--                 <svg>
                    <image xlink:href="img/ahuja.svg" src="svg.png">
                </svg> -->


                <p>The min-cost flow does not use the expensive edge with cost 3.</p></div>
<!--                 <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="https://i1.wp.com/cs.stanford.edu/people/trevisan/cs261-11/network1.png" alt="Flow problem in network routing capacity"><p>Flow problem in network routing capacity</p></div> -->

                <h1>The Min-Cost Flow Problem</h1>
                <p>Road system, water pipes, or data networks are the motivation for a class of optimisation problems termed <strong>flow problems</strong>. The shared characteristic for this type of system is that some kind of resource has to be transported over the edges of a graph, which are constrained to only carry only up to a certain amount of flow. For some instances edges also have other properties, making it useful to assign a cost for using a specific edge - for example variable toll charges in a network of highways.</p>

                <p>In this kind of setting it is interesting to compute how a certain flow can be routed through the network using the cheapest possible route. This problem is called the minimum-cost flow problem.</p>

                <h2>This applet presents the cycle cancelling algorithm to calculate a minimum-cost flow on a given network.</h2>
                <div id ="te_div_Entscheidung">
                    <h2>What do you want to do first?</h2>
                    <button id="te_button_gotoDrawGraph">Test the algorithm!</button> <button id="te_button_gotoIdee">Read detailed description of the algorithm</button>
                </div>
                <p></p>
                <br style="clear: both;" />
            </div>
        </div>

        <!-- TAB Graph Erstellen -->
        <div id="tab_tg">
            <div>
                <div class="canvasWrapper">
                    <div class="svgContainer">
                      <svg class="graphCanvas" id="tg_canvas_graph" width="700" height="500"></svg>
                      <a class="svgDownloader" download="graph-editor.svg" href="data:text/plain,test">Download Graph</a>
                    </div>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>Node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge with capacity 10 and cost 1</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tg_div_statusWindow" class="statusWindow">
                    <h2>Which graph do you want to execute the algorithm on?</h2>
                    <h3>Start with an example graphs:</h3>
                    <label for="graphSelector">Select </label>
                    <select name="graphSelector" id="tg_select_GraphSelector">
                        <option selected = true label="graph 1">graph1</option>
                        <option label="graph 2">graph2</option>
						<option label="graph 3">graph3</option>
						<option label="graph 4">graph4</option>
						<option label="graph 5">graph5</option>
						<option label="graph 6">graph6</option>
						<option label="graph 7">graph7</option>
						<option label="graph 8">graph8</option>
						<option label="graph 9">graph9</option>
                    </select>


                    <h3>Modify it to your desire:<br></h3>
                    <div id="tg_div_statusErklaerung">
                    <ul>
                        <li>To create a node, double-click in the drawing area.</li>
                        <li>To create an edge, first click on the output node and then click on the destination node.</li>
                        <li>The edge weight can be changed by double clicking on the edge.</li>
                        <li>Right-clicking deletes edges and nodes.</li>
                    </ul>
                    </div>

                    <h3>Download the modified graph:</h3>

                    <a id="fileDownloader" download="graph.txt" href="data:text/plain,test">Download</a>

                    <h3>Upload an existing graph:</h3>
                    <input type="file" id="fileUploader" accept=".txt"/></input> <!--name="files[]" accept="text/*"-->
                    <div id="ta_div_parseError" title="Error reading graph from file">
<!--                         <h2>Error code:</h2> -->
                        A
                        <h2 style="color:red" id="ta_div_parseErrorText"></h2>
                        occured when reading from file:
                        <h3 id="ta_div_parseErrorFilename"></h3>
                        the contents:
                        <pre id="ta_div_parseErrorDescription"></pre>
                    </div>

                    <h3>What next?</h3>
                   <p><button id="tg_button_gotoAlgorithmTab">Ready &ndash; Run the Algorithm!</button></p>


                </div>
            </div>
        </div>

        <!-- TAB Algorithmus ausführen -->
        <div id="tab_ta">
            <div>
                <div class="canvasWrapper">
                    <div class="svgContainer">
                        <svg class="graphCanvas" id="ta_canvas_graph" width="700" height="450"></svg>
					</div>
                        <a class="svgDownloader" download="maxflow-graph-algorithm-graph.svg" href="data:text/plain,test">Download SVG</a>
                    <div id="graph-info">
                        <span id="graph-state"></span>
                    </div>
                    <div id="cost-info">
                      <span id="currMinCost"></span>
                    </div>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>Node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-st.svg" alt="nodes" class="LegendeIcon"></td>
                                    <td><span>Source node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-t.svg" alt="nodet" class="LegendeIcon"></td>
                                    <td><span>Target node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge with flow 7, cap 10 and cost 1</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge in residual graph, cost 1</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-cycle.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge on negative cycle, cost 1</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="ta_div_statusWindow" class="statusWindow">
                    <h2 class="">Algorithm status</h2>
                    <div id="ta_div_abspielbuttons"> <!--class="ui-widget-header ui-corner-all"-->
                        <input  id="ta_button_rewind" type="checkbox"><label for="ta_button_rewind" id="ta_button_text_rewind">rewind</label>

                        <button id="ta_button_Zurueck">prev</button>

                        <button id="ta_button_1Schritt">next</button>

                        <input  id="ta_button_vorspulen" type="checkbox"><label for="ta_button_vorspulen" id="ta_button_text_fastforward">fast forward</label>

                        <span id="ta_button_text_pause" style="display:none">pause</span>
                    </div>
                     <div id="ta_div_statusTabs">
                         <ul>
                            <li><a href="#ta_div_statusErklaerung">Explanation</a></li>
                            <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                            <li><a href="#ta_div_statusVariables">Variable State</a></li>
                            <!--<li><a href="#ta_div_statusLogger">Log</a></li> -->
                        </ul>
                        <div id="ta_div_statusErklaerung">
                            <div id="explanation-select-source">
                                <h3>First choose a source node</h3>
                                <p> Please click on a node in the network to select it as the source/starting node
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>s</mi>
                                    </mstyle>
                                  </math>. The flow is going to start from this node. It will have no incoming flow and the outgoing flow is equal to the flowsize. </p>

                            </div>
                            <div id="explanation-select-target">
                                <h3>Then choose a target node</h3>
                                <p> Please click on a node in the network to select it as the target/sink node
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>t</mi>
                                    </mstyle>
                                  </math>. The flow ends in this node. The incoming flow of this node is equal to the flowsize and it has no outgoing flow. </p>

                            </div>
                            <div id="explanation-start-algorithm">
                                <h3>Cycle cancelling flow algorithm</h3>
                                <p>Now the algorithm can begin. Please click on <strong>next</strong> to start it.</p>
                            </div>
                            <div id="explanation-get-max-flow">
                                <h3>Initializing the flow</h3>
                                <p>  The algorithm computes the maximal flow, while ignoring the cost information, using the Edmonds-Karp algorithm, which is an implementation of the Ford-Fulkerson method.</p>
                                <p> The algorithm works as follows: </p>
                                <p> As long as there is a path in the <a href="">residual network</a> from the source
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>s</mi>
                                    </mstyle>
                                  </math>
                                   to the sink
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mstyle mathvariant="bold">
                                       <mi>t</mi>
                                     </mstyle>
                                   </math>
                                    with available capacity on all edges in the path, the algorithm sends flow along the shortest path until the edge with the smallest capacity saturates. The shortest path is found by using a <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breath first search</a>. The algorithm repeats those steps until there is no augmenting path (path with available capacity) from
                                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                                      <mstyle mathvariant="bold">
                                        <mi>s</mi>
                                      </mstyle>
                                    </math>
                                    to
                                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                                      <mstyle mathvariant="bold">
                                        <mi>t</mi>
                                      </mstyle>
                                    </math>
                                     left.</p>
                                <p> More detailed description of the Ford-Fulkerson method and initialization of a maximal flow can be found <a href="https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html">here</a>.</p>
                            </div>
                            <div id="explanation-main-loop">
                                <h3>Entering the main loop</h3>
                                <p> When the algorithm has found the maximal flow
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                  <mi>f</mi>
                                  <mo stretchy="false">(</mo>
                                  <mi>s</mi>
                                  <mo>,</mo>
                                  <mi>t</mi>
                                  <mo stretchy="false">)</mo>
                                  </math>
                                  , it builds the residual network
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <msub>
                                      <mi>G</mi>
                                      <mi>f</mi>
                                    </msub>
                                  </math>
                                   corresponding to this flow as follows:</p>
                                <p> Each edge
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mo stretchy="false">(</mo>
                                    <mi>v</mi>
                                    <mo>,</mo>
                                    <mi>w</mi>
                                    <mo stretchy="false">)</mo>
                                    <mo>&#x2208;<!-- ∈ --></mo>
                                    <mi>G</mi>
                                  </math>
                                   is replaced by two new edges
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mo stretchy="false">(</mo>
                                     <mi>v</mi>
                                     <mo>,</mo>
                                     <mi>w</mi>
                                     <mo stretchy="false">)</mo>
                                   </math>
                                   and
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mo stretchy="false">(</mo>
                                     <mi>w</mi>
                                     <mo>,</mo>
                                     <mi>v</mi>
                                     <mo stretchy="false">)</mo>
                                   </math>.</p>
                                   <p> The edge
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mo stretchy="false">(</mo>
                                     <mi>v</mi>
                                     <mo>,</mo>
                                     <mi>w</mi>
                                     <mo stretchy="false">)</mo>
                                   </math>
                                    has cost
                                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                                      <mi>c</mi>
                                      <mo stretchy="false">(</mo>
                                      <mi>v</mi>
                                      <mo>,</mo>
                                      <mi>w</mi>
                                      <mo stretchy="false">)</mo>
                                    </math>
                                     and residual capacity
                                     <math xmlns="http://www.w3.org/1998/Math/MathML">
                                       <mi>r</mi>
                                       <mo stretchy="false">(</mo>
                                       <mi>v</mi>
                                       <mo>,</mo>
                                       <mi>w</mi>
                                       <mo stretchy="false">)</mo>
                                       <mo>=</mo>
                                       <mi>u</mi>
                                       <mo stretchy="false">(</mo>
                                       <mi>v</mi>
                                       <mo>,</mo>
                                       <mi>w</mi>
                                       <mo stretchy="false">)</mo>
                                       <mo>&#x2212;<!-- − --></mo>
                                       <mi>f</mi>
                                       <mo stretchy="false">(</mo>
                                       <mi>v</mi>
                                       <mo>,</mo>
                                       <mi>w</mi>
                                       <mo stretchy="false">)</mo>
                                       <mo>&gt;</mo>
                                       <mn>0</mn>
                                     </math>
                                      , where
                                      <math xmlns="http://www.w3.org/1998/Math/MathML">
                                        <mi>u</mi>
                                        <mo stretchy="false">(</mo>
                                        <mi>v</mi>
                                        <mo>,</mo>
                                        <mi>w</mi>
                                        <mo stretchy="false">)</mo>
                                      </math>
                                       is the capacity of the edge and
                                       <math xmlns="http://www.w3.org/1998/Math/MathML">
                                         <mi>f</mi>
                                         <mo stretchy="false">(</mo>
                                         <mi>v</mi>
                                         <mo>,</mo>
                                         <mi>w</mi>
                                         <mo stretchy="false">)</mo>
                                       </math>
                                        is the flow through this edge.</p>
                                        <p> The second edge
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                          <mo stretchy="false">(</mo>
                                          <mi>w</mi>
                                          <mo>,</mo>
                                          <mi>v</mi>
                                          <mo stretchy="false">)</mo>
                                        </math>
                                         has cost
                                         <math xmlns="http://www.w3.org/1998/Math/MathML">
                                           <mi>c</mi>
                                           <mo stretchy="false">(</mo>
                                           <mi>w</mi>
                                           <mo>,</mo>
                                           <mi>v</mi>
                                           <mo stretchy="false">)</mo>
                                           <mo>=</mo>
                                           <mo>&#x2212;<!-- − --></mo>
                                           <mi>c</mi>
                                           <mo stretchy="false">(</mo>
                                           <mi>v</mi>
                                           <mo>,</mo>
                                           <mi>w</mi>
                                           <mo stretchy="false">)</mo>
                                         </math>
                                          and residual capacity
                                          <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>r</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>w</mi>
                                            <mo>,</mo>
                                            <mi>v</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>=</mo>
                                            <mi>f</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>&gt;</mo>
                                            <mn>0</mn>
                                          </math>.
                                         </p>
                                <p>The main loop repeatedly identifies negative cycles (i.e. cycles whose total weight is negative) in the residual graph. </p>
                                <p>If no negative cycle is found the algorithm terminates.</p>
                                <h3>Read more about residual networks or make an exercise: </h3>
                                    <center><button id="ta_button_gotoIdee" >Read detailed description of a residual network</button></center>
                                    <center><button id="ta_button_gotoExerciseResidualNetwork" >Exercise residual netwokt</button></center>

                            </div>
                            <div id="explanation-find-neg-cycle">
                                <h3>Find a negative cycle</h3>
                                <p>
                                  One finds negative cycles in the residual network by running the Bellman-Ford algorithm as follows:
                                </p>
                                <p> If
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mi>N</mi>
                                  </math> is the number of nodes in the network, the algorithm is first executed
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mi>N</mi>
                                    <mo>&#x2212;<!-- − --></mo>
                                    <mn>1</mn>
                                  </math>
                                   times and should have found the shortest path from
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mi>s</mi>
                                   </math>
                                   to
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mi>t</mi>
                                   </math>
                                   . Then the algorithm is executed one more time and if the shortest path found in the
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mo stretchy="false">(</mo>
                                     <mi>N</mi>
                                     <mo>&#x2212;<!-- − --></mo>
                                     <mn>1</mn>
                                     <mo stretchy="false">)</mo>
                                   </math>th execution has not changed, then there are no negative cost-directed cycles. Otherwise the algorithm takes a node the distance of which has changed, and goes from it via its ancestores until a cycle
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mi>W</mi>
                                   </math> is found.
                                   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                     <mi>W</mi>
                                   </math> is the negative cycle we were looking for. </p>
                                <p> More information on the Bellman-Ford algorithm can be found <a href="https://www-m9.ma.tum.de/graph-algorithms/spp-bellman-ford/index_en.html">here</a>.</p>
                            </div>
                            <div id="explanation-adjust-cycle">
                                <h3>Cancel Cycle</h3>
                                <p>When the algorithm finds a negative cycle, it augments </p>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                                  <mrow class="MJX-TeXAtom-ORD">
                                    <mo>&#x3B4;</mo>
                                  </mrow>
                                  <mo>:=</mo>
                                  <mi>m</mi>
                                  <mi>i</mi>
                                  <mi>n</mi>
                                  <mo fence="false" stretchy="false">{</mo>
                                  <mi>r</mi>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>:</mo>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>&#x2208;</mo>
                                  <mi>W</mi>
                                  <mo fence="false" stretchy="false">}</mo>
                                </math>
                          <p>units of flow in the cycle
                            <math xmlns="http://www.w3.org/1998/Math/MathML">
                              <mi>W</mi>
                            </math>
                             to saturate the edge with the minimal residual capacity, so the negative cycle
                             <math xmlns="http://www.w3.org/1998/Math/MathML">
                               <mi>W</mi>
                             </math>
                              is removed from the residual network.
                          </p>
                          <p> Then the algorithm goes back to the main loop to examine the residual graph for other negative cycles. </p>
                            </div>
                            <div id="explanation-finished">
                                <h3>Finished</h3>
                                <p>The algorithm terminated with maximal flow of:
                                <p id="finalflow" class="algoInfoTD" style="color:green">-</p>
                              and minimal cost for the flow:
                                <p id="minCost" class="algoInfoTD" style="color:green">-</p>
                              </p>
                                <p> The residual network contains no negative cost-directed cycles, therefore a minimum cost flow has been found.</p>
                                <h3>What now?</h3>
                                    <center><button id="ta_button_gotoId">Read the detiled description of the algorithm</button></center>
                                <h3> Test your knowledge on an exercise? </h3>
                                    <button id="ta_button_gotoExercise1" style="position:absolut">Exercise 1</button>
                            </div>
                        </div>

                        <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                            <div id="pseudocode-select-source">
                                <p>s &larr; pick(v)</p>
                            </div>
                            <div id="pseudocode-select-target">
                                <p>t &larr; pick(v)</p>
                            </div>
                            <div id="pseudocode-start-algorithm">
                                <p><strong>BEGIN</strong></p>
                                <p>| </p>
                            </div>
                            <div id="pseudocode-get-max-flow">
                                <p>|  (* Initialize max flow *)</p>
                                <p>|  CALCULATE MAX FLOW <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mi>f</mi>
                                    <mo stretchy="false">(</mo>
                                    <mi>s</mi>
                                    <mo>,</mo>
                                    <mi>t</mi>
                                    <mo stretchy="false">)</mo>
                                  </math> IN THE NETWORK </p>
                                   <p>|  USING THE FORD-FULKERSON ALGORITHM</p>
                                   <p>|  </p>
                            </div>
                            <div id="pseudocode-main-loop">
                                <p>|  (* Main Loop *)</p>
                                <p>|  <strong> WHILE</strong> (the residual network <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>G</mi><mi>f</mi></msub></math></p>
                                <p>|   |       contans a negative cycle) <strong>DO</strong></p>
                                <p>|   |</p>
                            </div>
                            <div id="pseudocode-find-neg-cycle">
                                <p>|   |  EXECUTE BELLMAN-FORD ALGORITHM TO</p>
                                <p>|   |  IDENTIFY A NEGATIVE CYCLE <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math>;</p>
                                <p>|   |   <strong>IF</strong> (negative cycle exists)<strong>THEN</strong></p>
                                <p>|   |   |   IDENTIFY cycle-edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mo stretchy="false">(</mo>
                                    <mi>v</mi>
                                    <mo>,</mo>
                                    <mi>w</mi>
                                    <mo stretchy="false">)</mo>
                                    <mo>&#x2208;<!-- ∈ --></mo>
                                    <mi>W</mi>
                                  </math>                                 </p>
                                <p>|   |   |   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                  <mi>&#x03B4;<!-- δ --></mi>
                                  <mo>:=</mo>
                                  <mi>m</mi>
                                  <mi>i</mi>
                                  <mi>n</mi>
                                  <mo fence="false" stretchy="false">{</mo>
                                    <mi>r</mi>
                                    <mo stretchy="false">(</mo>
                                    <mi>v</mi>
                                    <mo>,</mo>
                                    <mi>w</mi>
                                    <mo stretchy="false">)</mo>
                                    <mo>:</mo>
                                    <mo stretchy="false">(</mo>
                                    <mi>v</mi>
                                    <mo>,</mo>
                                    <mi>w</mi>
                                    <mo stretchy="false">)</mo>
                                    <mo>&#x2208;<!-- ∈ --></mo>
                                    <mi>W</mi>
                                    <mo fence="false" stretchy="false">}</mo>
                                  </math></p>
                                  <p>|   |   <strong>ENDIF</strong> </p>
                            </div>
                            <div id="pseudocode-adjust-cycle">
                                <p>|   |   <strong>FOR</strong> (<math xmlns="http://www.w3.org/1998/Math/MathML">
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>&#x2208;<!-- ∈ --></mo>
                                  <mi>W</mi>
                                </math>)</p>
                                <p>|   |   |  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                  <mi>f</mi>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>=</mo>
                                  <mi>f</mi>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>+</mo>
                                  <mi>&#x03B4;<!-- δ --></mi>
                                </math> </p>
                                <p>|   |   <strong>ENDFOR</strong> </p>
                                <p>|   |</p>
                                <p>|  <strong>ENDWHILE</strong></p>
                                <p>|</p>

                            </div>
                            <div id="pseudocode-finished">
                              <p><strong>END</strong></p>
                            </div>
                        </div>
                        <div id="ta_div_statusVariables">
                            <h3>Variable State</h3>
                            <table class="algoInformationen">
                                <tr>
                                    <th class="algoInfoTH"><span>cycle</span></th>
                                    <th class="algoInfoTH"><span>adjustment</span></th>
                                </tr>
                                <tr>
                                    <td id="variable-value-cycle" class="algoInfoTD">-</td>
                                    <td id="variable-value-adjustment" class="algoInfoTD">-</td>
                                </tr>
                            </table>
                        </div>
<!--                       <div id="ta_div_statusLogger">
                            <h3>Log of algorithm execution</h3>
                            <div id="logger"></div>
                        </div> -->
                    </div>


                </div>
            </div>
            <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
                <h2>If the tab is changed the algorithm is terminated.</h2>
                <p>You can open <a href="#" target="_blank" tabindex=-1> another browser window</a> to read another tab in parallel.</p>
            </div>
        </div>

        <!-- TAB Beschreibung des Algorithmus -->
        <div id="tab_ti" style="display: none;">
            <div id="ti_div_Einfuehrungstext">
				<div class="BeispielbildContainer"><img id="ti_img_einfuehrung" src="img/graph-editor.svg" alt="Simple graph with 4 nodes."><p><strong>Figure 1.</strong>What's the cheapest way to send maximal amount of flow from s to t?</p></div>
                <h1>Minimum-cost Flows</h1>
                  
                <p>
                Minimum-cost flow is a classic optimisation problem, which can be motivated by a typical decision problem: Given a transport network of roads, whose usage is restricted by varying capacities and incurs different cost, find the cheapest way to transport the maximal amount of goods from location s to location t.
                </p>
                <p>The corresponding mathematical model is made up of the following information: A directed graph
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>G</mi>
                    <mo stretchy="false">(</mo>
                    <mi>V</mi>
                    <mo>,</mo>
                    <mi>E</mi>
                    <mo stretchy="false">)</mo>
                  </math> modeling the network topology. An upper limit on the capacity of each edge, given by a function <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>,</mo>
                    <mi>e</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math>, and the cost function <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                  </math> which models how expensive it is to send one unit of flow along each edge. The last information required is a start and a goal node.</p>

                <p>The solution to the problem is a flow <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                </math> determining the usage of each edge which minimizes the total cost. The cost incurred by each edge is simply its flow times the cost of the edge. The solution also has to fulfill some constraints imposed on flows in general - each edge can only carry up to
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>u</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                </math> units of flow, and for all non-terminal nodes in the network the sum of incoming and outgoing flow has to be equal.</p>

                <p>The total amount of flow has to be fixed before optimising for cost. In this application we look at the specific problem of finding the cheapest realisation of the largest possible flow through the network - the min cost max flow problem.</p>
                <p>  </p>
                <p>  </p>

                <h1> Flow network </h1>
                <div class="BeispielbildContainer">
                    <img id="ti_img_flow_network" src="img/maxflow-graph-algorithm-graph.svg"   alt="Network with 4 nodes and max flow."><p><strong>Figure 2.</strong> Flow network <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>N</mi>
                    </math> with calculated maximal flow
                      <math xmlns="http://www.w3.org/1998/Math/MathML">
                        <mi>f</mi>
                      </math> (without considering the costs) and edge parameters <math xmlns="http://www.w3.org/1998/Math/MathML">
                          <mo stretchy="false">(</mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mo>/</mo>
                          </mrow>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mo>,</mo>
                          <mi>c</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mo stretchy="false">)</mo>
                        </math>.</p>
                </div>

                <p>Let
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>G</mi>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <mi>E</mi>
                  <mo>,</mo>
                  <mi>u</mi>
                  <mo stretchy="false">)</mo>
                </math> be a weighted digraph defined by a set
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>V</mi>
                </math> of
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>n</mi>
                </math> nodes, a set
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>E</mi>
                  <mo>=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mo stretchy="false">|</mo>
                    </mrow>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>V</mi>
                    <mo fence="false" stretchy="false">}</mo>
                  </math> of
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>m</mi>
                </math> directed edges and each edge
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                </math> has a capacity of
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>u</mi>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2265;<!-- ≥ --></mo>
                  <mn>0</mn>
                </math> that denotes the maximal amount of flow that can be send over the edge
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math>. The set of all incoming edges of a node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                </math> is defined as
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mi>w</mi>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>V</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <mo stretchy="false">(</mo>
                  <mi>w</mi>
                  <mo>,</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                  <mo fence="false" stretchy="false">}</mo>
                </math> and the set of all outgoing edges of node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                </math> is
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mi>w</mi>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>V</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                  <mo fence="false" stretchy="false">}</mo>
                </math>. Let also
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                </math> and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                </math> be the number of incoming edges and the number of outgoing edges from node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                </math> respectively.
              </p>
              <p> With this knowledge, one can define a flow network. A flow network
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>N</mi>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <mi>E</mi>
                  <mo>,</mo>
                  <mi>s</mi>
                  <mo>,</mo>
                  <mi>t</mi>
                  <mo>,</mo>
                  <mi>u</mi>
                  <mo stretchy="false">)</mo>
                </math> is a directed graph with a source node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>s</mi>
                </math> and a target node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>t</mi>
                </math>  for which holds
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>s</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>t</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mn>0</mn>
                </math> and a capacity function
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>u</mi>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> for every edge
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                </math>.
                If
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>N</mi>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <mi>E</mi>
                  <mo>,</mo>
                  <mi>s</mi>
                  <mo>,</mo>
                  <mi>t</mi>
                  <mo>,</mo>
                  <mi>u</mi>
                  <mo stretchy="false">)</mo>
                </math>
                is a flow network, then a <strong>flow</strong> in
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>N</mi>
                </math> is a mapping
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>:</mo>
                    <mi>E</mi>
                    <mo stretchy="false">&#x2192;<!-- → --></mo>
                    <mo stretchy="false">[</mo>
                    <mn>0</mn>
                    <mo>,</mo>
                    <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                    <mo stretchy="false">)</mo>
                  </math> that satisfies the following properties:
                  <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2264;<!-- ≤ --></mo>
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>,</mo>
                    <mtext>&#xA0;</mtext>
                    <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
                    <mi>e</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> In words: the amount of flow along an edge can not exceed the capacity of the edge. This condition is called <strong>capacity constraint</strong>. The second condition is that the amount of flow arriving in a node <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>v</mi></math> must be equal to the amount of flow leaving the node <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>v</mi></math>. Or formal:
                  <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>w</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <msup>
                          <mi>N</mi>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mi>i</mi>
                            <mi>n</mi>
                          </mrow>
                        </msup>
                        <mo stretchy="false">(</mo>
                        <mi>v</mi>
                        <mo stretchy="false">)</mo>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>w</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <msup>
                          <mi>N</mi>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mi>o</mi>
                            <mi>u</mi>
                            <mi>t</mi>
                          </mrow>
                        </msup>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>,</mo>
                    <mtext>&#xA0;</mtext>
                    <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
                    <mi>v</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>V</mi>
                    <mtext>&#xA0;\&#xA0;</mtext>
                    <mo fence="false" stretchy="false">{</mo>
                    <mi>s</mi>
                    <mo>,</mo>
                    <mi>t</mi>
                    <mo fence="false" stretchy="false">}</mo>
                  </math>
                    <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/be08.svg" alt="Transformation."><p><strong>Figure 3.</strong> Transformation of parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>1</mn>
                      </msub>
                      <mo>=</mo>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> with equal costs.</p>
                </div>
                  This condition does not apply for the source and sink nodes
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>s</mi>
                  </math> and
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>t</mi>
                  </math>. The incoming flow of
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>s</mi>
                  </math> is equal to the outgoing flow of
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>t</mi>
                  </math> and they both are
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mn>0</mn>
                  </math>.From the second condition follows an important property of the flow, namely the flow leaving from
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>s</mi>
                  </math> must be equal to the flow arriving at
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>t</mi>
                  </math>. Also each node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>V</mi>
                  </math> is associated with an integer number <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math> that represents its supply/demand. If <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&gt;</mo>
                    <mn>0</mn>
                  </math>, node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> is a <strong>supply node</strong>, if <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&lt;</mo>
                    <mn>0</mn>
                  </math>, node  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> is a <strong>demand node</strong> with a demand of <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math>, and if <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mn>0</mn>
                  </math>, node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> is a <strong>transshipment node </strong>.
                </p>
                <p>
                  Some network flow problems, like the minimum cost flow, also need a cost function <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> which is a mapping <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>:</mo>
                    <mi>E</mi>
                    <mo stretchy="false">&#x2192;<!-- → --></mo>
                    <mo stretchy="false">[</mo>
                    <mo>-</mo>
                    <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                    <mo>,</mo>
                    <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                    <mo stretchy="false">)</mo>
                  </math>, that models how expensive it is to send one unit of flow along each edge. The cost of the flow is calculated as
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>e</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <mi>E</mi>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2217;<!-- ∗ --></mo>
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                  </math>.
                  The structure of the flow network can lead to some inconsistencies which because of the cost can only be avoided with a network tranformation.
                  That is the reason why in this applet some additional conditions are posed. In order for the applet to function correctly, the including of paralell
                  edges is forbidden.
                  Paralell edges are edges that start from the same node and end in the same node, i.e <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>1</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math>.
                
                If there were no costs associated with the edges, one could simply sum the capacities of those edges and combine
                  them in one edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>e</mi>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    </math>.
					
					<div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig4.svg" alt="Transformation."><p><strong>Figure 4.</strong> Transformation of two parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> with different costs.</p>
                </div>
				
                    This transformation can also be valid if the costs of the both edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>1</mn>
                      </msub>
                    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                  </math> are equal which is not always the case, as shown in Figure 3. If the costs of the edges are not equal, one will need to transform the flow network further.
                  If there exist two edges with the same start and end node a new node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>k</mi>
                  </math> is added to the flow network and one of the paralell edges is redirected through this node. That means, that one of the edges
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mi>i</mi>
                    </msub>
                    <mtext>,&#xA0;</mtext>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mo fence="false" stretchy="false">{</mo>
                    <mn>1</mn>
                    <mo>,</mo>
                    <mn>2</mn>
                    <mo fence="false" stretchy="false">}</mo>
                  </math>, lets say <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                  </math>, is replaced by the two new edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>k</mi>
                    <mo stretchy="false">)</mo>
                  </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>k</mi>
                    <mo stretchy="false">)</mo>
                  </math> has the same cost and capacity as the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>2</mn>
                      </msub>
                    </math> and the second edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mn>0</mn>
                  </math>, so the transformation does not influence the cost of the flow, and capacity <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                    <mo stretchy="false">)</mo>
                  </math>. This transformation is grafically shown in Figure 4.
                </p>
                <p> Another notational problem are the opposite edges. Two edges are opposite, if the start node of the first edge is the same as the end node of the second
                  edge and the end node of the first edge is the same as the start node of the second one: <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math>. If the costs of the both edges are equal, the transformation is easy. One can remove the edge with the smaller capacity by substracting it from the
              capacity of the other edge, as shown in Figure 5. If the costs are not equal, both edges have to remain in some form in the flow network. This can be
              achieved with the same transformation as for the parallel edges with different costs from above, which is also shown for opposite edges in Figure 6.

              <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig5.svg" alt="Transformation."><p><strong>Figure 5.</strong>Transformation of opposite edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>e</mi>
                <mn>2</mn>
              </msub>
              <mo>=</mo>
              <mo stretchy="false">(</mo>
              <mi>v</mi>
              <mo>,</mo>
              <mi>w</mi>
              <mo stretchy="false">)</mo>
            </math> with equal costs.</p>
          </div>

<!--    -->

                	<h1>Residual network </h1>
                <p> In order to work with flows, one often makes use of residual networks, for example to find the maximal flow or to calculate the minimal cost for a flow in a network. The concept of residual networks is based on the following intuitive idea. If edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> carries <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> units of flow, then one can send additional <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> units of flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>w</mi>
                  </math> along the edge   <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                  </math>. One can also cancel (some of) the existing flow on the edge   <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </math> sending up to <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math> units of flow from mode <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math>. While sending a unit of flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> over the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </math> increases the flow cost by <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>c</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math>, sending a unit of flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math> decreases the flow cost by <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>c</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math>.
                </p>
                <p>
                  By using this ideas, one defines the residual network <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>N</mi>
                      <mi>f</mi>
                    </msub>
                  </math>
                   with respect to a given flow <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>f</mi>
                  </math> as follows:
                  <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig6.svg" alt="Transformation."><p><strong>Figure 6.</strong>Transformation of two opposite edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> with different costs.</p>
				</div>
                   Each edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> in the original network is replaced by two new edges
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math>: the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and residual capacity
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and the edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and residual capacity <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math>  (see Figure 7.). The residual network conists only of edges with positive residual capacity, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&gt;</mo>
                    <mn>0</mn>
                    <mtext>,&#xA0;</mtext>
                    <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <msub>
                      <mi>E</mi>
                      <mi>f</mi>
                    </msub>
                  </math>
                </p>
                To summaryse, a residual network is defined as <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>N</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>:=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <msub>
                    <mi>E</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>s</mi>
                  <mo>,</mo>
                  <mi>t</mi>
                  <mo>,</mo>
                  <msub>
                    <mi>u</mi>
                    <mi>f</mi>
                  </msub>
                  <mo stretchy="false">)</mo>
                </math>, with
                <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <msub>
                    <mi>u</mi>
                    <mi>f</mi>
                  </msub>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow>
                    <mo>{</mo>
                    <mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false">
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&#x2212;<!-- − --></mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&gt;</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>+</mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>w</mi>
                          <mo>,</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>w</mi>
                          <mo>,</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&gt;</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, otherwise</mtext>
                        </mtd>
                      </mtr>
                    </mtable>
                    <mo fence="true" stretchy="true" symmetric="true"></mo>
                  </mrow>
                </math> and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>E</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msub>
                    <mi>c</mi>
                    <mi>f</mi>
                  </msub>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&gt;</mo>
                  <mn>0</mn>
                  <mo fence="false" stretchy="false">}</mo>
                </math>

              </p>

              <p>
                 <math xmlns="http://www.w3.org/1998/Math/MathML">

                            <mtext>&#xA0;</mtext>

                          </math>     </p>
				<div class="BeispielbildContainer"><img id="ti_img_res3" src="img/res1.svg" alt="Residual network of the original network."><p><strong>Figure 7.</strong> An edge <math>
                        <mi> e </mi>
                      </math> in a flow network, with flow, capacity, and cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                        <mo stretchy="false">(</mo>
                        <mi>f</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mrow class="MJX-TeXAtom-ORD">
                          <mo>/</mo>
                        </mrow>
                        <mi>u</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mo>,</mo>
                        <mi>c</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mo stretchy="false">)</mo>
                      </math></p>
				</div>

              <p> However, the concept of residual networks can create some notatinal difficulties. This happens when the flow network contains both edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
                </math>
                and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math> then the residual network can contain two parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> or <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math> with different cots and residual capacities. If this happens, the edge
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> will no longer define a unique edge cost and residual capacity. That is why one assumes, without los of generality, that for every node pair <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>v</mi>
                <mtext>&#xA0;and&#xA0;</mtext>
                <mi>w</mi>
              </math> the flow network <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>N</mi>
              </math> contains only one of the edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> or 
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math>. If that is not the case one needs to use the transformations described above to remove one of the edges.
            </p>
			
            <h1>Min-cost flow problem </h1>  
			<div class="BeispielbildContainer"><img id="ti_img_res3" src="img/res2.svg" alt="Transformation of an edge in residual network."><p><strong>Figure 8.</strong>
				The edge <math xmlns="http://www.w3.org/1998/Math/MathML">
				<mi>e</mi>
				</math> from Figure 7.</p>
				</div>
            <p>
              Let <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>N</mi>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>V</mi>
                <mo>,</mo>
                <mi>E</mi>
                <mo>,</mo>
                <mi>s</mi>
                <mo>,</mo>
                <mi>t</mi>
                <mo>,</mo>
                <mi>u</mi>
                <mo stretchy="false">)</mo>
              </math> be a flow network,
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>c</mi>
                <mo>:</mo>
                <mi>E</mi>
                <mo stretchy="false">&#x2192;<!-- → --></mo>
                <mo stretchy="false">[</mo>
				<mo>-</mo>
                <mi>&#x221E;</mi>
                <mo>,</mo>
                <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                <mo stretchy="false">)</mo>
              </math> a cost function and <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>d</mi>
                <mo>&#x2265;<!-- ≥ --></mo>
                <mn>0</mn>
              </math> the required flow amount. The problem: Find a flow
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                </math> with <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                  <mi>a</mi>
                  <mi>l</mi>
                  <mo stretchy="false">(</mo>
                  <mi>f</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>d</mi>
                </math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                  <mi>a</mi>
                  <mi>l</mi>
                  <mo stretchy="false">(</mo>
                  <mi>f</mi>
                  <mo stretchy="false">)</mo>
                </math> is the amount of flow in <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                </math>, such that
				
				
				
                <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <munder>
                    <mo>&#x2211;<!-- ∑ --></mo>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>e</mi>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </mrow>
                  </munder>
                  <mi>c</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x22C5;<!-- ⋅ --></mo>
                  <mi>f</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>m</mi>
                  <mi>i</mi>
                  <mi>n</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo maxsize="2.047em" minsize="2.047em">{</mo>
                  </mrow>
                  <munder>
                    <mo>&#x2211;<!-- ∑ --></mo>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>e</mi>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </mrow>
                  </munder>
                  <mi>c</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x22C5;<!-- ⋅ --></mo>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mtext>&#xA0;is flow in&#xA0;</mtext>
                  <mi>N</mi>
                  <mtext>&#xA0;with&#xA0;</mtext>
                  <mi>v</mi>
                  <mi>a</mi>
                  <mi>l</mi>
                  <mo stretchy="false">(</mo>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>d</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo maxsize="2.047em" minsize="2.047em">}</mo>
                  </mrow>
                </math>
				
                is called <strong>minimum cost flow problem</strong>. A feasible flow <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                </math> is an optimal solution of the minimum cost flow problem if and only if the residual network <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>N</mi>
                    <mi>f</mi>
                  </msub>
                </math> contains no negative cost cycle. This condition is called <strong>negative cycle optimality condition</strong>.
            </p>

            <p>This applet uses the max-flow as <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>d</mi>
            </math>, i.e. it solves the <strong>min-cost-max-flow problem</strong>. </p>

                <h1>Idea of the Cycle Cancelling Algorithm</h1>
				<div class="BeispielbildContainer"><img id="ti_img_res3" src="img/res3.svg" alt="Residual network of the original network."><p><strong>Figure 9.</strong> The residual network corresponding to the network flow <math xmlns="http://www.w3.org/1998/Math/MathML">
					<mi>N</mi>
				  </math> in Figure 2.</p>
				</div>


                <p>The cycle-cancelling algorithm is based on the negative cost cycle optimality condition and it takes an iterative approach, starting with any feasible flow with the desired magnitude (e.g. feasible flow can be obtained with a max-flow algorithm). The algorithm maintains a feasible flow
                    <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>f</mi></math> and at every iteration attempts to reduce the cost by moving some of the flow to cheaper edges without violating the flow coonstraints. The algorithm first finds a maximum flow without considering the costs, using the Edmonds-Karp implementation of the Ford-Fulkerson method.
                    Basically Edmonds-Karp algorithm starts with a flow of
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                      <mo>=</mo>
                      <mn>0</mn>
                    </math>, then it builds the residual network
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>N</mi>
                        <mi>f</mi>
                      </msub>
                    </math>, ignoring the costs, and finds the shortest path
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>P</mi>
                    </math>
                     from the source node
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>s</mi>
                    </math>
                     to the target node
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>t</mi>
                    </math>
                     and augments
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>g</mi>
                      <mo>=</mo>
                      <mi>m</mi>
                      <mi>i</mi>
                      <mi>n</mi>
                      <mo fence="false" stretchy="false">{</mo>
                      <mi>r</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mo stretchy="false">|</mo>
                      </mrow>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>P</mi>
                      <mo fence="false" stretchy="false">}</mo>
                    </math>
                     units of flow along
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>P</mi>
                    </math>
                    , to saturate the edge
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>P</mi>
                    </math>
                     with the minimal capacity. Then updates the current flow
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                      <mo>=</mo>
                      <mi>f</mi>
                      <mo>&#x2295;<!-- ⊕ --></mo>
                      <mi>g</mi>
                    </math>. The algorithm repeats these steps until there is no path
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>P</mi>
                    </math> in the residual network
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>N</mi>
                        <mi>f</mi>
                      </msub>
                    </math>. For more details see <a href = "https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html">Ford-Fulkerson</a>.</p>
                    After the maximal flow
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                    </math> has been found, the algorithm builds the residual network
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>N</mi>
                        <mi>f</mi>
                      </msub>
                    </math> associated with the flow
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                    </math>, taking the costs into account as described above. Then the algorithm starts searching for a negative cycle
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>W</mi>
                    </math> in
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>N</mi>
                        <mi>f</mi>
                      </msub>
                    </math>. Sending flow along a cycle in the residual graph always leads to another valid flow and keeps the total flow constant.
                    If the sum of the costs for the edges in the cycle is negative, changing the flow will reduce the overall cost and improve the solution.
                    The <a href = "https://www-m9.ma.tum.de/graph-algorithms/spp-bellman-ford/index_en.html">Bellman-Ford algorithm</a> is used for finding
                    negative cycles. Bellman-Ford algorithm finds the shortest path from
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>s</mi>
                    </math>
                     to
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>t</mi>
                    </math>
                     in a graph after
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>n</mi>
                      <mo>&#x2212;<!-- − --></mo>
                      <mn>1</mn>
                    </math> phases, where
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>n</mi>
                    </math>
                     is the number of nodes in the graph
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>n</mi>
                      <mo>=</mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mo stretchy="false">|</mo>
                      </mrow>
                      <mi>V</mi>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mo stretchy="false">|</mo>
                      </mrow>
                    </math>
                     and a phase is "looking once at all edges of the graph and updating the costs of the nodes". If after iterating all phases, the algorithm can still shorten the shortest path, then there is a negative cycle
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>W</mi>
                    </math> in the graph. The edges and the nodes of which the cycle is composed can be found by going back from the target node
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>t</mi>
                    </math> until a cycle is traversed.
                  </p>

				  <div class="BeispielbildContainer"><img id="ti_img_neg_cycle" src="img/neg_cycle.svg" alt="Negative cycle in residual network."><p><strong>Figure 10.</strong> A negative cost cycle <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mo stretchy="false">[</mo>
                  <mi>t</mi>
                  <mo stretchy="false">&#x2192;<!-- → --></mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="false">&#x2192;<!-- → --></mo>
                  <mn>2</mn>
                  <mo>,</mo>
                  <mn>2</mn>
                  <mo stretchy="false">&#x2192;<!-- → --></mo>
                  <mi>t</mi>
                  <mo stretchy="false">]</mo>
                </math> found with the Bellamn-Ford algorithm in the residual network in Figure 9. </p>
				</div>
				  
                <p>
                    After identifying a negative cost cycle in the residual network (Figure 10.), the algorithm redirects <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>&#x03B4;<!-- δ --></mi>
                      <mo>:=</mo>
                      <mi>m</mi>
                      <mi>i</mi>
                      <mi>n</mi>
                      <mo fence="false" stretchy="false">{</mo>
                      <mi>r</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mo stretchy="false">|</mo>
                      </mrow>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>W</mi>
                      <mo fence="false" stretchy="false">}</mo>
                    </math>
                    units of flow along the cycle <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math>  in the graph. The edges and
                    the nodes, of which the cycle <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>W</mi>
                    </math> is composed, can be found by going back from the target node and saturates the edge with the lowest residual
                    capaciy. This removes the edge from the residual network, therby removing the negative cost cycle <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>W</mi></math>. Since the new residual network might still contain other negative cost cycles, the algorithm iterates by running
                    the Bellman-Ford algorithm again. When the residual network contains no more negative cost cycles, the algorithm has found the minimum
                    cost flow and terminates.
                </p>

                <h1>What now?</h1>
				<br style="clear: both;" />
                <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                    <h3>Create a graph and play through the algorithm</h3>
                    <button id="ti_button_gotoDrawGraph">Try algorithm after creating a graph</button>
                    <button id="ti_button_gotoAlgorithm">Try algorithm on an example graph</button>
                </div>
                <!--<br style="clear: both;" />-->
				<div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                    <h3>Test your knowledge in the exercises</h3>
                    <button id="ti_button_gotoExerciseResidualNetwork">Exercise: Residual network </button><br>
                    <button id="ti_button_gotoExercise1">Exercise: Min-Cost-Flow</button>
                </div>
                <br style="clear: both;" />
            </div>
		</div>



        <!-- Tab exercise 1 -->
        <div id="tab_tf1" >
            <div>
                <div class="canvasWrapper">
                    <div class="svgContainer">
                    <svg class="graphCanvas" id="tf1_canvas_graph" width="700" height="450"></svg>
                    </div>
                    <a class="svgDownloader" download="graph-algorithm.svg" href="data:text/plain,test">SVG Download</a>

                    <!-- Legende maximized-->

                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>Node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-st.svg" alt="nodes" class="LegendeIcon"></td>
                                    <td><span>Source node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-t.svg" alt="nodet" class="LegendeIcon"></td>
                                    <td><span>Target node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge in residual graph, cost 1</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-cycle.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge on negative cycle, cost 1</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <!-- Legende minimized -->
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>

                </div>
                <!-- rechter Teil -->

                <div id="tf1_div_statusWindow" class="statusWindow">
                   <center> <h2  id= "f1-start" class="">Choose a graph and try to answer the questions while running the algorithm!</h2>
					<h2 id = "f1_started"> Answer the questions while running the algorithm!</h2></center>
                   
					<!--<select name="graphSelector" id="tf1_graphSelector">
					<option selected = true label="graph1">graph1</option>
					<option label="graph2">graph2</option>
					<option label="graph3">graph3</option>						
					<option label="graph4">graph4</option>
					<option label="graph5">graph5</option>
					<option label="graph6">graph6</option>
					<option label="graph7">graph7</option>
					<option label="graph8">graph8</option>
					<option label="graph9">graph9</option>
					</select>-->

              <br>

              <button id="tf1_button_start">Start Exercise</button> 
                    <div id="tf1_div_abspielbuttons">
						<input  id="tf1_button_rewind" type="checkbox"><label for="tf1_button_rewind" id="tf1_button_text_rewind">rewind</label>
						
                        <button id="tf1_button_1Schritt">Next Step</button>

                        <input  id="tf1_button_vorspulen" type="checkbox"><label for="tf1_button_vorspulen" id="tf1_button_text_fastforward">Forward: Next question</label>

                        <span id="tf1_button_text_pause" style="display:none">Pause</span>
                    </div>
                    <div id="tf1_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
                    </div>
                    <div id="tf1_div_statusTabs">
                         <ul>
                            <li><a href="#tf1_div_statusErklaerung">Explanation</a></li>
                            <li><a href="#tf1_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <!-- Status Erklärung -->
                        <div id="tf1_div_statusErklaerung">
						<div id="explanation-select-source">
                                <h3>First choose a source node</h3>
                                <p> Please click on a node in the network to select it as the source/starting node
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>s</mi>
                                    </mstyle>
                                  </math>. The flow is going to start from this node. It will have no incoming flow and the outgoing flow is equal to the flowsize. </p>

                            </div>
                            <div id="explanation-select-target">
                                <h3>Then choose a target node</h3>
                                <p> Please click on a node in the network to select it as the target/sink node
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>t</mi>
                                    </mstyle>
                                  </math>. The flow ends in this node. The incoming flow of this node is equal to the flowsize and it has no outgoing flow. </p>

                            </div>
                            <div id="explanation-start-algorithm">
                                <h3>Cycle cancelling flow algorithm</h3>
                                <p>Now the algorithm can begin. Please click on <strong>next</strong> to start it.</p>
                            </div>
                            <div id="explanation-get-max-flow">
                                <h3>Initializing the flow</h3>
                                <p>  The algorithm computes the maximal flow, while ignoring the cost information, using the Edmonds-Karp algorithm, which is an implementation of the Ford-Fulkerson method.</p>
                                
                            </div>
                            <div id="explanation-main-loop">
                                <h3>Entering the main loop</h3>
                                <p> When the algorithm has found the maximal flow
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                  <mi>f</mi>
                                  <mo stretchy="false">(</mo>
                                  <mi>s</mi>
                                  <mo>,</mo>
                                  <mi>t</mi>
                                  <mo stretchy="false">)</mo>
                                  </math>
                                  , it builds the residual network
                                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <msub>
                                      <mi>G</mi>
                                      <mi>f</mi>
                                    </msub>
                                  </math>
                                   corresponding to this flow.</p>
                                <p>The main loop repeatedly identifies negative cycles (i.e. cycles whose total weight is negative) in the residual graph. </p>
                                <p>If no negative cycle is found the algorithm terminates.</p>
                            </div>
                            <div id="explanation-find-neg-cycle">
                                <h3>Find a negative cycle</h3>
                                <p>The algorithm runs the Bellman-Ford algorithm to find negative cycles in the residual network <math> <msub>
                                      <mi>G</mi>
                                      <mi>f</mi>
                                    </msub>
                                  </math>.</p>
                            </div>
                            <div id="explanation-adjust-cycle">
                                <h3>Cancel Cycle</h3>
                                <p>When the algorithm finds a negative cycle, it augments </p>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                                  <mrow class="MJX-TeXAtom-ORD">
                                    <mo>&#x3B4;</mo>
                                  </mrow>
                                  <mo>:=</mo>
                                  <mi>m</mi>
                                  <mi>i</mi>
                                  <mi>n</mi>
                                  <mo fence="false" stretchy="false">{</mo>
                                  <mi>r</mi>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>:</mo>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>&#x2208;</mo>
                                  <mi>W</mi>
                                  <mo fence="false" stretchy="false">}</mo>
                                </math>
                          <p>units of flow in the cycle
                            <math xmlns="http://www.w3.org/1998/Math/MathML">
                              <mi>W</mi>
                            </math>
                             to saturate the edge with the minimal residual capacity, so the negative cycle
                             <math xmlns="http://www.w3.org/1998/Math/MathML">
                               <mi>W</mi>
                             </math>
                              is removed from the residual network.
                          </p>
                          <p> Then the algorithm goes back to the main loop to examine the residual graph for other negative cycles. </p>
                            </div>
                            <div id="explanation-finished">
                                <h3>Finished</h3>
                                <p>The algorithm terminated. The residual network contains no negative cost-directed cycles, therefore a minimum cost flow has been found.</p>
                                
                            </div>
                        </div>

                        <!-- Tab Pseudocode-->
                        <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
							<div id="fr-pseudocode-select-source">
								<p>s &larr; pick(v)</p>
							</div>
							<div id="fr-pseudocode-select-target">
								<p>t &larr; pick(v)</p>
							</div>
							<div id="fr-pseudocode-start-algorithm">
								<p><strong>BEGIN</strong></p>
								<p>| </p>
							</div>
							<div id="pseudocode-get-max-flow">
                                <p>|  (* Initialize max flow *)</p>
                                <p>|  CALCULATE MAX FLOW <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mi>f</mi>
                                    <mo stretchy="false">(</mo>
                                    <mi>s</mi>
                                    <mo>,</mo>
                                    <mi>t</mi>
                                    <mo stretchy="false">)</mo>
                                  </math> IN THE NETWORK </p>
                                   <p>|  USING THE FORD-FULKERSON ALGORITHM</p>
                                   <p>|  </p>
                            </div>
							<div id="fr-pseudocode-main-loop">
								<p>|  (* Main Loop *)</p>
								<p>|  <strong> WHILE</strong> (the residual network <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>G</mi><mi>f</mi></msub></math></p>
								<p>|   |       contans a negative cycle) <strong>DO</strong></p>
								<p>|   |</p>
							</div>
							<div id="fr-pseudocode-find-neg-cycle">
								<p>|   |  EXECUTE BELLMAN-FORD ALGORITHM TO</p>
								<p>|   |  IDENTIFY A NEGATIVE CYCLE <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math>;</p>
								<p>|   |   <strong>IF</strong> (negative cycle exists)<strong>THEN</strong></p>
								<p>|   |   |   IDENTIFY cycle-edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>&#x2208;<!-- ∈ --></mo>
                                  <mi>W</mi>
                                </math>                                 </p>
								<p>|   |   |   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                <mi>&#x03B4;<!-- δ --></mi>
                                <mo>:=</mo>
                                <mi>m</mi>
                                <mi>i</mi>
                                <mi>n</mi>
                                <mo fence="false" stretchy="false">{</mo>
                                  <mi>r</mi>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>:</mo>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>&#x2208;<!-- ∈ --></mo>
                                  <mi>W</mi>
                                  <mo fence="false" stretchy="false">}</mo>
                                </math></p>
                                <p>|   |   <strong>ENDIF</strong> </p>
							</div>
							<div id="fr-pseudocode-adjust-cycle">
								<p>|   |   <strong>FOR</strong> (<math xmlns="http://www.w3.org/1998/Math/MathML">
                                <mo stretchy="false">(</mo>
                                <mi>v</mi>
                                <mo>,</mo>
                                <mi>w</mi>
                                <mo stretchy="false">)</mo>
                                <mo>&#x2208;<!-- ∈ --></mo>
                                <mi>W</mi>
                              </math>)</p>
                              <p>|   |   |  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                <mi>f</mi>
                                <mo stretchy="false">(</mo>
                                <mi>v</mi>
                                <mo>,</mo>
                                <mi>w</mi>
                                <mo stretchy="false">)</mo>
                                <mo>=</mo>
                                <mi>f</mi>
                                <mo stretchy="false">(</mo>
                                <mi>v</mi>
                                <mo>,</mo>
                                <mi>w</mi>
                                <mo stretchy="false">)</mo>
                                <mo>+</mo>
                                <mi>&#x03B4;<!-- δ --></mi>
                              </math> </p>
                              <p>|   |   <strong>ENDFOR</strong> </p>
                              <p>|   |</p>
                              <p>|  <strong>ENDWHILE</strong></p>
                              <p>|</p>
							</div>
							<div id="fr-pseudocode-finished">
								<p><strong>END</strong></p>
							</div>
                        </div>
					</div>
                </div>
            </div>
             <!-- </div>-->
            <div id="tf1_div_TabIntroDialog" title="Exercise 1" class="tabIntroDialog">
                <h2>In this part you can test your knowledge: What would the algorithm do?</h2>
                <p>
                    The algorithm will be executed normally, but will stop in a few places. Then you will have to predict, what the algorithm would do next.
                </p>
                <p>Hint: Recall the description of the algorithm.</p>
            </div>
            <div id="tf1_div_confirmTabChange" title="Terminate the algorithm?" class="tabChangeWarningDialog">
                <h2>If you switch tabs, the execution will be terminated.</h2>
                <p>You can open <a href="#" target="_blank" tabindex="-1">another browser window</a> to read the description in parallel.</p>
            </div>
        </div>
		
		
		
		
		<div id="tab_tf2">

			<div>
	<!--  Graph auf linker Seite -->
				<div class="canvasWrapper">
					<div class="svgContainer">
						<svg class="graphCanvas" id="tf2_canvas_graph" width="700" height="450"></svg>
					</div>

					<a class="svgDownloader" download="graph-algorithm.svg" href="data:text/plain,test">SVG Download</a>


	<!--Graph informationen: Graph anzeigen-->
					<div id="f2-graph-info">
						<span id="f2-graph-state"> </span>
					</div>

					<div id="f2-graph-flow">
						<span id="f2-flow-st"> </span>
					</div>

    <!-- Legende maximized-->
					<div class="Legende">
						<h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>

						<div class="LegendeText">
							<table>
								<tr>
									<td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
									<td><span>Knoten</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-st.svg" alt="node" class="LegendeIcon"></td>
									<td><span>S/T Knoten</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>Kante mit Kapazität 10 und Fluss 7.</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>Kante im Residualgraphen.</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-augmenting.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>Kante auf augmentierendem Pfad.</span></td>
								</tr>
							</table>
						</div>
					</div>

       <!-- Legende minimized -->
					<div class="LegendeMinimized">
						<h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
					</div>


				</div>

    <!-- rechter Teil -->
				<div id="tf2_div_statusWindow" class="statusWindow">
					<h2 class="">Build the corresponding residual netwprk!</h2>
	
				<div id="tf2_div_abspielbuttons">
           <!--  <input  id="tf2_button_rewind" type="checkbox"><label for="tf2_button_rewind" id="tf2_button_text_rewind">rewind</label> -->

					<button id="tf2_button_1Schritt">Next Network</button>

            <!--  <input  id="tf2_button_vorspulen" type="checkbox"><label for="tf2_button_vorspulen" id="tf2_button_text_fastforward">Zur nächsten Frage vorspulen</label> -->

            <!--  <span id="tf2_button_text_pause" style="display:none">Pause</span> -->
				</div>

				<div id="tf2_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
				</div>

				<div id="tf2_div_statusTabs">
					<ul>
						<li><a href="#tf2_div_statusErklaerung">Explanation</a></li>
                <!--<li><a href="#tf2_div_statusPseudocode">Pseudocode</a></li> -->
					</ul>

				<div id="tf2_div_statusErklaerung">
					<p>In the following exercise you will get different networks \(N\) with the respective capacities, flow values and costs \(u(e)\), \(f(e)\) and \(c(e)\) for all edges \(e \in E\), based on a current flow \(f\).</p>
					<p> Your task is to fill the missing residual capacities \(r(e')\) bzw. \(r(e'')\) of the out- and  ingoing edges \(e'\) und \(e''\) in the corresponding residual network
                <math>
                  <msub>
                    <mi>N</mi>
                    <mi>f</mi>
                 </msub>
                </math>.</p>

              <br>

              <center>
              <h2 id= "f2-start"> Choose a number of networks for the exercise:</h2>

              <select name="graphSelector" id="tf2_Selector">
                <option selected = true label="3">3</option>
                <option label="4">4</option>
                <option label="5">5</option>
                <option label="6">6</option>
                <option label="7">7</option>
                <option label="8">8</option>
				<option label="9">9</option>
                </select>

              <br>
              <p> </p>

              <button id="tf2_button_start">Klick here to start!</button> </center>
                <!-- <img id="tf2_img_1" src="img/Bes/ex01.svg" alt="Suche" width="250"/> -->

            </div>




            <!-- Tab Pseudocode
            <div class="PseudocodeWrapper" id="tf2_div_statusPseudocode">

            </div>
            -->


			</div>
		</div>
	</div>

  <div id="tf2_div_TabIntroDialog" title="Exercise 2" class="tabIntroDialog">

                <h2>In this part you can practice the construction of residual networks!</h2>
                <p>
                    You will get a network with current flow. Your task is to fill out the missing residual capacities and costs in the residual network!
                </p>
				
                <p><strong>Tip:</strong> Before you start read the information on residual networks again.</p>
				<p><strong> WARNING! </p></strong>
				<p> You can set the missing residual capacities and costs only once. When a value is set it can not be changed any more. </p>
                <p>Good Luck!</p>
            </div>
            <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">

				<h2>If you switch tabs, the execution will be terminated.</h2>
                <p>You can open <a href="#" target="_blank" tabindex="-1">another browser window</a> to read another tab in parallel.</p>
            </div>

		</div>

        <!-- TAB Weiteres -->
        <div id="tab_tw" style="display: none;">
            <div id="tw_Accordion">
                <h3>What is the pseudocode of the algorithm?</h3>
                <div>
                    <pre><code>Input: directed graph G=(V,E), capacity function u(e), cost function c(e), source and target node
                      Output: minimum-cost max flow f(e)</code></pre>
                      <hr>
                      <pre>
                      <code>BEGIN
                        (* Initialize to max flow *)
                        f = CALCULATE MAX FLOW()
                        (* Main Loop *)
                        WHILE negative cycle might exist DO
                          CONSTRUCT RESIDUAL GRAPH G'(V,E') WITH CAPACITIES u'(e)
                          EXECUTE BELLMAN-FORD ON G' FROM TARGET NODE
                          IF negative cycle exists
                            IDENTIFY cycle-edges
                            adjustment &larr; min(u'(e) | e &isin; cycle-edges )
                            FOR e &isin; cycle-edges
                              f(e) += adjustment
                      END
                      </code></pre>
                </div>

                <h3>How efficient is the algorithm?</h3>
                <div>
                    <p>The generic cycle cancelling algorithm has the non-polynomial runtime O(|E| |V| C), with C being the total cost of the initial flow - as each iteration requires a run of Bellman-Ford in O(|E| |V|) and reduces the cost by at least 1.</p>
                    <p>There are multiple more complex algorithms for the min-cost flow problem which achieve better runtimes. One adaption of the cycle cancelling algorithm is <strong> minimum mean cycle cancelling</strong>, which already results in a strongly polynomial algorithm. Other algorithms can e.g. be found <a href="https://en.wikipedia.org/wiki/Minimum-cost_flow_problem#Solutions">here</a>.</p>
                </div>

                <h3>References</h3>
                <div>
                  <h4>Literature</h4>
                    <dl>
                    <dt>[GT89]</dt><dd> Andrew V. Goldberg and Robert E. Tarjan (1989). "Finding minimum-cost circulations by canceling negative cycles". Journal of the ACM. 36 (4): 873–886. doi:<a href="https://dx.doi.org/10.1145%2F76359.76368">10.1145/76359.76368</a>.</dd>
                    </dl>

                    <h4>Web resources</h4>
                  <ol>
                      <li><a href="https://en.wikipedia.org/wiki/Minimum-cost_flow_problem">Wikipedia: Minimum-cost flow problem</a></li>
                      <li><a href="http://www.columbia.edu/~cs2035/courses/ieor6614.S16/mcf.pdf">Minimum Cost Flows</a></li>
                  </ol>
                </div>

                <h3>Where can I find more information about graph algorithms?</h3>
                <div><p>Other graph algorithms are explained on the <a href="http://www-m9.ma.tum.de/Allgemeines/Routenplanung">Website of Chair M9</a> of the TU München.</p>
                  <p><a href="http://www.ma.tum.de/Studium/StudieninteressierteEn">Studying mathematics at the TU München</a> answers all questions about graph theory (if an answer is known).</p>
                </div>
                <h3>A last remark about this page's goal and citations</h3>
				         <div><p>Chair M9 of Technische Universität München does research in the fields of discrete mathematics, applied geometry and the optimization of mathematical problems. The algorithms presented on the pages at hand are very basic examples for methods of discrete mathematics (the research conducted daily at the chair reaches far beyond that point). This page shall provide the possibility pupils and students to understand and fully comprehend the algorithms (which are of importance also in daily life).</p>
            				<p>To cite this page, please use the following information:</p>
            				<ul>
            				<li>Title: Cycle-Cancelling Algorithm</li>
            				<li>Authors: Quirin Fischer, Wolfgang F. Riedl; Technische Universität München</li>
            				<li>Link: <a href="https://www-m9.ma.tum.de/graph-algorithms/flow-cycle-cancelling">https://www-m9.ma.tum.de/graph-algorithms/flow-cycle-cancelling</a></li>
            				</ul>
            		</div>

            </div>
        </div>
    </div>

    <!--Ende Tabs -->
    <footer>
        <p class="Disclaimer">
            IDP Project of Quirin Fischer at Chair M9 of Technische Universität München. 2016 | <a href="index_de.html">DE</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Terms of use</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">About Us</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Suggestions</a>
        </p>
    </footer>
</body>
