<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="Der Cycle Cancelling Algorithmus zur Berechnung kostenminimaler Flüsse" />
    <meta name="keywords" content="Cycle, Cancelling, minimum cost flow, algorithm, TUM, Technische Universität München, Applet">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="author" content="Quirin Fischer, Gergana Kratuncheva">

<!--     the whole page layout style -->
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />

    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
 <!--   <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/smoothness/jquery-ui.css"> -->

 <!--     MathJax, used in the more tab in pseudocode -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>

<!-- LOCAL -->

    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <link type="text/css" href="../library/css/mmenu/jquery.mmenu.all.css" rel="stylesheet" />
    <script type="text/javascript" src="../library/js/mmenu/jquery.mmenu.min.all.js"></script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=en"></script>
    <script src="../library/js/d3/d3.js"></script>

<!-- CDN
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <link type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jQuery.mmenu/5.3.4/css/jquery.mmenu.all.min.css" rel="stylesheet" />
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jQuery.mmenu/5.3.4/js/jquery.mmenu.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=en"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
-->
<!--     Adrians d3 related library code -->
    <script src="../library-d3-svg/js/Graph.js"></script>
    <script src="../library-d3-svg/js/GraphDrawer.js"></script>
    <script src="../library-d3-svg/js/GraphEditor.js"></script>
    <script src="../library-d3-svg/js/Logger.js"></script>
    <script src="../library-d3-svg/js/Tab.js"></script>
    <script src="../library-d3-svg/js/AlgorithmTab.js"></script>
    <script src="../library-d3-svg/js/GraphEditorTab.js"></script>
    <script src="../library-d3-svg/js/siteAnimation.js"></script>

	
    <!-- lNG -->
    <script src="../library/js/lang.js" type="text/javascript"></script>
    <script src="../library/js/utilities.js" type="text/javascript"></script>

	
    <script src="js/ExerciseTab1.js" ></script>
    <script src="js/Exercise1.js"></script>
	<script src="js/ExerciseTab2.js"></script>
	<script src="js/Exercise2.js"></script>
	
	
    <link rel="stylesheet" type="text/css" href="../library-d3-svg/css/graph-style.css" />
    <link rel="stylesheet" type="text/css" href="../library-d3-svg/css/style.css" />

<!--     Files used only for this applet -->
    <script src="js/siteLayout.js" type="text/javascript"></script>
    <script src="js/CycleCancellingAlgorithm.js" type="text/javascript"></script>


    <title>Cycle Cancelling Algorithmen für Min-Cost-Flow Probleme </title>
</head>
<body>
<!-- svg definitons -->
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xlink="http://www.w3.org/1999/xlink">
      <defs>
        <marker id="arrowhead2" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-red" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(196, 7, 27)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-lightRed" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(240, 128, 128)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-green" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(115, 183, 141)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>
      </defs>
    </svg>
    <noscript>
        <div class="ui-widget">
            <div class="ui-state-error ui-corner-all" style="padding: .7em;">
                <div class="ui-icon ui-icon-alert errorIcon"></div>
                <strong>Bitte aktivieren Sie Javascript!</strong>
                <ul style="margin: 0px;">
                    <li>
                         Diese Seite benötigt Javascript, um ordnungsgemäß angezeigt zu werden.
                    </li>
                    <li>
                        In Ihrem Browser ist Javascript aktuell deaktiviert. Eine Anleitung zur Aktivierung von Javascript finden Sie beispielsweise <a href="http://www.enable-javascript.com/">hier</a>.
                    </li>
                </ul>
            </div>
        </div>
    </noscript>
    <script>
        $(function() {
            initializeSiteLayout(CycleCancellingAlgorithm);

        });
		<!--LNG.setLanguage('en');-->
        $(document).ready(function() {
            $("#menu").mmenu({
               "navbar": {
                  "title": "Übersicht"
               },
               "offCanvas": {
                  "zposition": "front"
               },
               "counters": true,
               "slidingSubmenus": true,
               "classes": "mm-light",
            });
         });
    </script>
    <a id="menu_link" href="#menu"></a>
    <nav id="menu">
        <ul>
            <li>
                <a style="white-space:pre-line" href="http://www-m9.ma.tum.de/Allgemeines/GraphAlgorithmenEn">
                <img src="../library/img/logo_ohne.png" alt="Overview Graph Algorithms">
                Übersichtsseite Graphalgorithmen</a>
            </li>
            <li><span>Kürzeste-Wege - Algorithmen</span>
                <ul>
                   <li><a href="../spp-dijkstra/index_en.html">Dijkstra - Algorithmus</a></li>
                   <li><a href="../spp-a-star/index_en.html">A* Algorithmus</a></li>
                   <li><a href="../spp-bellman-ford/index_en.html">Bellman-Ford Algorithmus</a></li>
                   <li><a href="../spp-floyd-warshall/index_en.html">Floyd-Warshall Algorithmus</a></li>
                   <!--<li><a href="../spprc-label-setting/index_en.html">Label-Setting Algorithm</a></li>-->
                </ul>
            </li>
            <li><span>Spannbaum - Algorithmen</span>
                <ul>
                   <li><a href="../mst-prim/index_en.html">Algorithmus von Prim</a></li>
                   <li><a href="../mst-kruskal/index_en.html">Algorithmus von Kruskal</a></li>
                </ul>
            </li>
            <li><span>Fluss - Algorithmen</span>
                <ul>
                   <li><a href="../flow-ford-fulkerson/index_en.html">Algorithmus von Ford und Fulkerson</a></li>
                   <li class="Selected"><a href="../flow-cycle-cancelling/index_en.html">Cycle-Cancelling Algorithmus</a></li>
				   <!-- TODO: Add SSP Algorithmus and Algorithmus von Dinic wenn fertig -->
				   
				   
                   <!--<li><a href="../flow-push-relabel/index_en.html">Push-Relabel Algorithm</a></li>-->
                </ul>
            </li>
            <li><span>Matching - Algorithmen</span>
                <ul>
                   <li><a href="../matchings-hopcroft-karp/index_en.html">Algorithmus von Hopcroft-Karp</a></li>
                   <li><a href="../matchings-hungarian-method/index_en.html">Ungarische Methode</a></li>
                   <li><a href="../matchings-blossom-algorithm/index_en.html">Blossom-Algorithmus von Edmonds</a></li>
                </ul>
            </li>
            <li><span>Eulerwege und Briefträgerproblem</span>
                <ul>
                   <li><a href="../hierholzer/index_en.html">Algorithmus von Hierholzer</a></li>
                   <li><a href="../directed-chinese-postman/index_en.html">Chinesisches Postboten-Problem</a></li>
                </ul>
            </li>
        </ul>
    </nav>
    <!--<div>-->
    <header>
        <img src="img/title.svg" alt="A maximum flow"></img>
        <span class="adrianheader">Der Cycle Cancelling Algorithmus</span>
        <img style="position:absolute; right:0px" src="../library/img/TUMLogo.png" alt="Technische Universität München">
    </header>

<!--     <svg height="0px" widht ="0px">
        <defs>
        <marker id="arrowhead2" refX="12" refY="2" markerWidth="12" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker>
        </defs>
    </svg> -->
    <div id="tabs">
        <ul>
		    <!-- Define your tabs -->
            <li><a href="#tab_te"><span>Einführung</span></a></li>
            <li><a href="#tab_tg"><span>Graph erstellen</span></a></li>
            <li><a href="#tab_ta"><span>Algorithmus ausführen</span></a></li>
            <li><a href="#tab_ti"><span>Beschreibung des Algorithmus</span></a></li>
            <li><a href="#tab_tf1"><span>Forschungsaufgabe 1</span></a></li>
            <li><a href="#tab_tf2"><span>Forschungsaufgabe 2</span></a></li>
            <li><a href="#tab_tw"><span>Weiteres</span></a></li>
        </ul>

		
		
            <!-- TAB Einführung -->
            <div id="tab_te">
                <div id="te_div_Einfuehrungstext">
                    <div id="te_div_beispiel1Container">
                        <div id="svgtest"></div>
                        <img id="te_img_beispiel1" src="img/ahuja.svg" alt="ahuja">
                        <!--                 <object data="img/ahuja.svg" type="image/svg+xml" width="300px"> -->
                        <!--                 type="image/svg+xml"-->
                        <!--                 <svg>
                            <image xlink:href="img/ahuja.svg" src="svg.png">
                            </svg> -->
                        <p>Der kostenminimale Fluss nutzt nicht die teure Kante mit Kosten 3.</p>
                    </div>
                    <!--                 <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="https://i1.wp.com/cs.stanford.edu/people/trevisan/cs261-11/network1.png" alt="Flow problem in network routing capacity"><p>Flow problem in network routing capacity</p></div> -->
                    <h1>Das Min-Cost Flow Problem</h1>
                    <p>Die Planung von Straßennetzen, Pipelines or Datennetzwerken sind die Motivation für die <strong>Flussprobleme</strong> genannte Klasse von Optimierungsproblem. Der charakterisierende Aspekt der zu planenden Netzwerke ist, dass eine Art Ressource durch die Kanten eines Netzwerks transportiert werden muss, welche jedoch nur eine bestimmte Menge an Fluss zulassen. Für manche der Optimierungsprobleme haben diese Transportkanten noch weitere Eigenschaften, welche es zum Beispiel motivieren, den Kanten Kosten zuzuweisen - beispielsweise Mautgebühren für die Nutzung von Straßen.</p>
                    <p>In solch einer Problemstellung ist es interessant, wie ein bestimmter Fluss mit minimalen Kosten durch das Netzwerk geschickt werden kann. Diese Problem wird das Min-Cost Flow Problem genannt.</p>
                    <h2>Dieses Applet präsentiert den Cycle-Cancelling Algorithmus, welcher in einem gegebenen Netzwerk einen kostenminimalen Fluss berechnet.</h2>
                    <div id ="te_div_Entscheidung">
                        <h2>Was möchtest du zuerst tun?</h2>
                        <button id="te_button_gotoDrawGraph">Den Algorithmus testen!</button> <button id="te_button_gotoIdee">Genauere Beschreibung des Algorithmus lesen</button>
                    </div>
                    <p></p>
                    <br style="clear: both;" />
                </div>
            </div>
            
			
			<!-- TAB Graph Erstellen -->
            <div id="tab_tg">
                <div>
                    <div class="canvasWrapper">
                        <div class="svgContainer">
                            <svg class="graphCanvas" id="tg_canvas_graph" width="700" height="500"></svg>
                            <a class="svgDownloader" download="graph-editor.svg" href="data:text/plain,test">SVG Download</a>
                        </div>
                        <div class="Legende" id="tg_div_Legende">
                            <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                            <div class="LegendeText">
                                <table>
                                    <tr>
                                        <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                        <td><span>Knoten</span></td>
                                    </tr>
                                    <tr>
                                        <td class="LegendeTabelle"><img src="img/edge.svg" alt="edge" class="LegendeIcon"></td>
                                        <td><span>Kante mit Kapazität 10 und Kosten 1</span></td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="LegendeMinimized">
                            <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        </div>
                    </div>
                    <div id="tg_div_statusWindow" class="statusWindow">
                        <h2>Auf welchem Graph soll der Algorithmus ausgeführt werden?</h2>
                        <h3>Nimm ein fertiges Beispiel:</h3>
                        <label for="graphSelector">Wähle aus </label>
                        <select name="graphSelector" id="tg_select_GraphSelector">
                            <option selected = true label="graph 1">graph1</option>
                            <option label="graph 2">graph2</option>
                            <option label="graph 3">graph3</option>
                            <option label="graph 4">graph4</option>
                            <option label="graph 5">graph5</option>
                            <option label="graph 6">graph6</option>
                            <option label="graph 7">graph7</option>
                            <option label="graph 8">graph8</option>
                            <option label="graph 9">graph9</option>
                        </select>
                        <h3>Ändere den Graphen nach deinen Vorstellungen:<br></h3>
                        <div id="tg_div_statusErklaerung">
                            <ul>
                                <li>Um einen Knoten zu erstellen, mache einen Doppelklick in das Zeichenfeld.</li>
                                <li>Um eine Kante zu erstellen, klicke zunächst auf den Ausgangsknoten und dann auf den Zielknoten.</li>
                                <li>Das Kantengewicht kann mit einem Doppelklick auf die Kante verändert werden.</li>
                                <li>Ein Rechtsklick löscht Kanten und Knoten.</li>
                            </ul>
                        </div>
                        <h3>Lade den veränderten Graphen herunter:</h3>
                        <a id="fileDownloader" download="graph.txt" href="data:text/plain,test">Download</a>
                        <h3>Lade einen existierenden Graphen hoch:</h3>
                        <input type="file" id="fileUploader" accept=".txt"/></input> <!--name="files[]" accept="text/*"-->
                        <div id="ta_div_parseError" title="Error reading graph from file">
                            <!--                         <h2>Error code:</h2> -->
                            Ein
                            <h2 style="color:red" id="ta_div_parseErrorText"></h2>
                            trat auf beim Lesen der Datei:
                            <h3 id="ta_div_parseErrorFilename"></h3>
                            Fehlerbeschreibung:
                            <pre id="ta_div_parseErrorDescription"></pre>
                        </div>
                        <h3>Was nun?</h3>
                        <p><button id="tg_button_gotoAlgorithmTab">Fertig &ndash; weiter zum Algorithmus!</button></p>
                    </div>
                </div>
            </div>
			
			
            <!-- TAB Algorithmus ausführen -->
            <div id="tab_ta">
                <div>
                    <div class="canvasWrapper">
                        <div class="svgContainer">
                            <svg class="graphCanvas" id="ta_canvas_graph" width="700" height="450"></svg>
						</div>
                            <a class="svgDownloader" download="maxflow-graph-algorithm-graph.svg" href="data:text/plain,test">SVG Download</a>
                        
                        <div id="graph-info">
                            <span id="graph-state"></span>
                        </div>
                        <div id="cost-info">
                            <span id="currMinCost"></span>
                        </div>
                        <div class="Legende">
                            <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                            <div class="LegendeText">
                                <table>
                                    <tr>
                                        <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                        <td><span>Knoten</span></td>
                                    </tr>
                                    <tr>
                                        <td class="LegendeTabelle"><img src="img/node-st.svg" alt="node" class="LegendeIcon"></td>
                                        <td><span>S/T Knoten</span></td>
                                    </tr>
                                    <tr>
                                        <td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
                                        <td><span>Kante mit Fluss 7, Kapazität 10 und Kosten 1</span></td>
                                    </tr>
                                    <tr>
                                        <td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
                                        <td><span>Kante im Residualnetzwerk, Kosten 1</span></td>
                                    </tr>
                                    <tr>
                                        <td class="LegendeTabelle"><img src="img/edge-cycle.svg" alt="edge" class="LegendeIcon"></td>
                                        <td><span>Kante auf negativem Kreis, Kosten 1</span></td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="LegendeMinimized">
                            <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        </div>
                    </div>
                    <div id="ta_div_statusWindow" class="statusWindow">
                        <h2 class="">Algorithm status</h2>
                        <div id="ta_div_abspielbuttons">
                            <!--class="ui-widget-header ui-corner-all"-->
                            <input  id="ta_button_rewind" type="checkbox"><label for="ta_button_rewind" id="ta_button_text_rewind">rewind</label>
                            <button id="ta_button_Zurueck">Zurück</button>
                            <button id="ta_button_1Schritt">Nächster Schritt</button>
                            <input  id="ta_button_vorspulen" type="checkbox"><label for="ta_button_vorspulen" id="ta_button_text_fastforward">Vorspulen</label>
                            <span id="ta_button_text_pause" style="display:none">Pause</span>
                        </div>
                        <div id="ta_div_statusTabs">
                            <ul>
                                <li><a href="#ta_div_statusErklaerung">Erklärung</a></li>
                                <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                                <li><a href="#ta_div_statusVariables">Variablen</a></li>
                                <!--<li><a href="#ta_div_statusLogger">Log</a></li> -->
                            </ul>
                            <div id="ta_div_statusErklaerung">
                                <div id="explanation-select-source">
                                    <h3>Wähle zuerst einen Quellknoten aus</h3>
                                    <p>
                                        Klicken Sie bitte auf einen Knoten in dem Netzwerk, um ihn als Quelle/Startknoten
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mstyle mathvariant="bold">
                                                <mi>s</mi>
                                            </mstyle>
                                        </math>
                                        auszuwählen. Der Fluss geht von diesem Knoten aus. Dieser Knoten hat keinen reinfließenden Fluss und den rausfließenden Fluss ist gleich der Flussstärke. 
                                    </p>
                                    
                                </div>
                                <div id="explanation-select-target">
                                    <h3>Wähle nun eine Senke aus</h3>
                                    <p>
                                        Klicken Sie bitte auf einen Knoten in dem Netzwerk, um ihn als Senke/Zielknoten
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mstyle mathvariant="bold">
                                                <mi>t</mi>
                                            </mstyle>
                                        </math>
                                        auszuwählen. Der Fluss endet in diesem Knoten. Der reinfließende Fluss dieses Knotens ist gleich die Flussstärke und es gibt keinen rausfließenden Fluss.
                                    </p>
                                </div>
                                <div id="explanation-start-algorithm">
                                    <h3>Der Cycle Cancelling Algorithmus</h3>
                                    <p>Der Algorithmus kann nun starten. Klicken Sie bitte auf <strong>Nächster Schritt</strong>, um ihn zu starten.</p>
                                </div>
                                <div id="explanation-get-max-flow">
                                    <h3>Initialisiere den Fluss</h3>
                                    <p>Der Algorithmus berechnet den maximalen Fluss mithilfe von Edmonds-Karp-Algorithmus, der eine Implementierung der Ford-Fulkerson-Methode ist, ohne die Kantenkosten zu berücksichtigen. </p>
                                    <p>Der Algorithmus funktioniert wie folgt: </p>
                                    <p>
                                        Solange es im Residualnetzwerk einen Weg von dem Quellknoten
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mstyle mathvariant="bold">
                                                <mi>s</mi>
                                            </mstyle>
                                        </math>
                                        zur Senke
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mstyle mathvariant="bold">
                                                <mi>t</mi>
                                            </mstyle>
                                        </math>
                                        gibt, mit Kapazität
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mo>&gt;</mo>
                                            <mn>0</mn>
                                        </math>
                                        auf allen Kanten im Weg, sendet der Algorithmus so viel Flusseinheiten über dem kürzesten Weg, bis die Kante mit der kleinsten Kapazität saturiert wird. Der kürzeste Weg wird mithilfe von <a href="https://de.wikipedia.org/wiki/Breitensuche">Breitensuche</a> gefunden. Der Algorithmus wiederholt diese Schritte, bis es keinen Augmentationspfad (Pfad mit positiver Kapazität) von
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mstyle mathvariant="bold">
                                                <mi>s</mi>
                                            </mstyle>
                                        </math>
                                        zu
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mstyle mathvariant="bold">
                                                <mi>t</mi>
                                            </mstyle>
                                        </math>
                                        mehr gibt. 
                                    </p>
                                    <p>Detailierter Beschreibung der Ford-Fulkerson-Methode und Initialisierung von maximalen Flüssen ist <a href="https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_de.html">hier</a> zu finden.
                                </div>
                                <div id="explanation-main-loop">
                                    <h3>Beginne die Hauptschleife</h3>
                                    <p>
                                        Wenn der Algorithmus den maximalen Fluss
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>f</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>s</mi>
                                            <mo>,</mo>
                                            <mi>t</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        gefunden hat, erstellt er der Residualgraph
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <msub>
                                                <mi>G</mi>
                                                <mi>f</mi>
                                            </msub>
                                        </math>
                                        </math> zu diesem Fluss wie folgt:
                                    <p>
                                        Jede Kante
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>
                                                &#x2208;<!-- ∈ -->
                                            </mo>
                                            <mi>G</mi>
                                        </math>
                                        wird durch zwei neue Kanten
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        und
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mo stretchy="false">(</mo>
                                            <mi>w</mi>
                                            <mo>,</mo>
                                            <mi>v</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        ersetzt.
                                    </p>
                                    <p>
                                        Die Kante
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        hat Kosten
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>c</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        und Restkapazität
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>r</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>=</mo>
                                            <mi>u</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>
                                                &#x2212;<!-- − -->
                                            </mo>
                                            <mi>f</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>&gt;</mo>
                                            <mn>0</mn>
                                        </math>
                                        ,wobei
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>u</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        ist die Kapazität der Kante und
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>f</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        der Fluss durch die Kante.
                                    </p>
                                    <p>
                                        Die zweite (Rückwärts-)Kante
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mo stretchy="false">(</mo>
                                            <mi>w</mi>
                                            <mo>,</mo>
                                            <mi>v</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        hat Kosten
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>c</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>w</mi>
                                            <mo>,</mo>
                                            <mi>v</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>=</mo>
                                            <mo>
                                                &#x2212;<!-- − -->
                                            </mo>
                                            <mi>c</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        und Restkapazität
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>r</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>w</mi>
                                            <mo>,</mo>
                                            <mi>v</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>=</mo>
                                            <mi>f</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>&gt;</mo>
                                            <mn>0</mn>
                                        </math>
                                        .
                                    </p>
                                    <p>Die Hauptschleife sucht in jeder Iteration nach negativen Kreisen (d.h. nach Kreisen, deren Gesamtgewicht negativ ist) im Residualgraph.</p>
                                    <p>Falls kein negativer Kreis gefunden wird, terminiert der Algorithmus.</p>
                                    <h3>Mehr über Residualgraphen lesen oder üben: </h3>
                                    <center><button id="ta_button_gotoIdee" style="positin:absolute">Lese genauere Beschreibung von Residualgraph</button></center>
                                    <center><button id="tu_button_gotoUebungResidualgraph" style="positin:absolute">Übe bildung von Resudualgraph an eine Aufgabe</button></center>
                                </div>
                                <div id="explanation-find-neg-cycle">
                                    <h3>Suche einen negativen Kreis</h3>
                                    <p>
                                        Man findet in dem Residualgraph negativen Kreisen, indem man den Bellman-Ford-Algorithmus wie folgt ausführt:
                                    </p>
                                    <p>
                                        Wenn
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>N</mi>
                                        </math>
                                        die Anzahl der Knoten in dem Graph ist, wird der Algorithmus zuerst
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>N</mi>
                                            <mo>
                                                &#x2212;<!-- − -->
                                            </mo>
                                            <mn>1</mn>
                                        </math>
                                        mal ausgeführt und sollte den kürzesten Weg von
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>s</mi>
                                        </math>
                                        nach
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>t</mi>
                                        </math>
                                        gefunden haben. Dann wird der Algorithmus noch einmal ausgeführt und wenn der kürzeste Weg, der in der
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>N</mi>
                                            <mo>
                                                &#x2212;<!-- − -->
                                            </mo>
                                            <mn>1</mn>
                                        </math>
                                        -ten Ausführung gefunden wurde, sich nicht verändert hat, gibt es keinen negativen Kreis. Andernfalls nimmt der Algorithmus einen Knoten, dessen Abstand sich geändert hat, und geht von ihm über seine Vorgänger, bis einen Kreis
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>W</mi>
                                        </math>
                                        gefunden wird.
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>W</mi>
                                        </math>
                                        ist der gesuchte negative Kreis.  
                                    </p>
                                    <p> Weitere Informationen zum Bellman-Ford-Algorithmus findet man <a href="https://www-m9.ma.tum.de/graph-algorithms/spp-bellman-ford/index_de.html">hier</a>.</p>
                                </div>
                                <div id="explanation-adjust-cycle">
                                    <h3>Eliminiere Kreis</h3>
                                    <p>
                                        Wenn der Algorithmus einen negativen Kreis findet, augmentiert er
                                        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                                            <mrow class="MJX-TeXAtom-ORD">
                                                <mo>&#x3B4;</mo>
                                            </mrow>
                                            <mo>:=</mo>
                                            <mi>m</mi>
                                            <mi>i</mi>
                                            <mi>n</mi>
                                            <mo fence="false" stretchy="false">{</mo>
                                            <mi>r</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>:</mo>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>&#x2208;</mo>
                                            <mi>W</mi>
                                            <mo fence="false" stretchy="false">}</mo>
                                        </math>
                                        Floweinheiten durch den Kreis
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>W</mi>
                                        </math>
                                        , um die Kante mit minimalen Restkapazität zu saturieren (d.h. mit Fluss ausfüllen), sodass der negative Kreis
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>W</mi>
                                        </math>
                                        aus dem Residualgraph entfernt wird.
                                    </p>
                                    <p> Dann geht der Algorithmus zurück zur Hauptschleife, um den Residualgraph für andere negative Kreise zu überprüfen. </p>
                                </div>
                                <div id="explanation-finished">
                                    <h3>Fertig</h3>
                                    <p>Der Algorithmus terminiert mit maximalem Fluss von:
                                    <p id="finalflow" class="algoInfoTD" style="color:green">-</p>
                                    und minimalen Kosten für diesen Fluss:
                                    <p id="minCost" class="algoInfoTD" style="color:green">-</p>
                                    </p>
                                    <p>Der Residualgraph enthält keine negativen Kreise, daher wird ein Min-Cost-Flow gefunden. </p>
                                    <h3>Was nun?</h3>
                                    <center><button id="ta_button_gotoId">Beschreibung des Algorithmus lesen</button></center>
                                    <h3> Forschungsaufgaben ausprobieren? </h3>
                                    <button id="tx_button_gotoErsteUebung" style="positin:absolute">Forschungsaufgabe 1</button>
                                </div>
                            </div>
                            <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                                <div id="pseudocode-select-source">
                                    <p>s &larr; wähle(v)</p>
                                </div>
                                <div id="pseudocode-select-target">
                                    <p>t &larr; wähle(v)</p>
                                </div>
                                <div id="pseudocode-start-algorithm">
                                    <p><strong>BEGIN</strong></p>
                                    <p>| </p>
                                </div>
                                <div id="pseudocode-get-max-flow">
                                    <p>|  (* Initialisiere max. Fluss *)</p>
                                    <p>
                                        |  BERECHNE MAX FLOW 
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>f</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>s</mi>
                                            <mo>,</mo>
                                            <mi>t</mi>
                                            <mo stretchy="false">)</mo>
                                        </math>
                                        IM NETZWERK 
                                    </p>
                                    <p>|  MIT FORD-FULKERSON-ALGORITHMUS</p>
                                    <p>| </p>
                                </div>
                                <div id="pseudocode-main-loop">
                                    <p>|  (* Hauptschleife *)</p>
                                    <p>
                                        |  <strong>WHILE</strong> (dem Residualnetzwerk 
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <msub>
                                                <mi>G</mi>
                                                <mi>f</mi>
                                            </msub>
                                        </math>
                                        einen
                                    </p>
                                    <p>|   |       negativen Kreis besitzt) <strong>DO</strong></p>
                                    <p>|   |</p>
                                </div>
                                <div id="pseudocode-find-neg-cycle">
                                    <p>|   |  FÜHRE BELLMAN-FORD-ALGORITHMUS AUS</p>
                                    <p>
                                        |   |  UM NEGATIVE KREISE 
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>W</mi>
                                        </math>
                                        ZU
                                    </p>
                                    <p>|   |  IDENTIFIZIEREN;</p>
                                    <p>|   |   <strong>IF</strong> (negativer Kreis gefunden)<strong>THEN</strong></p>
                                    <p>|   |   |    IDENTIFIZIERE Kreiskanten</p>
                                    <p>
                                        |   |   |    
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>
                                                &#x2208;<!-- ∈ -->
                                            </mo>
                                            <mi>W</mi>
                                        </math>
                                    </p>
                                    <p>
                                        |   |   |    
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>
                                                &#x03B4;<!-- δ -->
                                            </mi>
                                            <mo>:=</mo>
                                            <mi>m</mi>
                                            <mi>i</mi>
                                            <mi>n</mi>
                                            <mo fence="false" stretchy="false">{</mo>
                                            <mi>r</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>:</mo>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>
                                                &#x2208;<!-- ∈ -->
                                            </mo>
                                            <mi>W</mi>
                                            <mo fence="false" stretchy="false">}</mo>
                                        </math>
                                    </p>
                                    <p>|   |   <strong>ENDIF</strong> </p>
                                </div>
                                <div id="pseudocode-adjust-cycle">
                                    <p>
                                        |   |   <strong>FOR</strong> (
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>
                                                &#x2208;<!-- ∈ -->
                                            </mo>
                                            <mi>W</mi>
                                        </math>
                                        )
                                    </p>
                                    <p>
                                        |   |   |   
                                        <math xmlns="http://www.w3.org/1998/Math/MathML">
                                            <mi>f</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>=</mo>
                                            <mi>f</mi>
                                            <mo stretchy="false">(</mo>
                                            <mi>v</mi>
                                            <mo>,</mo>
                                            <mi>w</mi>
                                            <mo stretchy="false">)</mo>
                                            <mo>+</mo>
                                            <mi>
                                                &#x03B4;<!-- δ -->
                                            </mi>
                                        </math>
                                    </p>
                                    <p>|   |   <strong>ENDFOR</strong> </p>
                                    <p>|   |</p>
                                    <p>|  <strong>ENDWHILE</strong></p>
                                    <p>|</p>
                                </div>
                                <div id="pseudocode-finished">
                                    <p><strong>END</strong></p>
                                </div>
                            </div>
                            <div id="ta_div_statusVariables">
                                <h3>Variablen</h3>
                                <table class="algoInformationen">
                                    <tr>
                                        <th class="algoInfoTH"><span>Kreis</span></th>
                                        <th class="algoInfoTH"><span>Anpassung</span></th>
                                    </tr>
                                    <tr>
                                        <td id="variable-value-cycle" class="algoInfoTD">-</td>
                                        <td id="variable-value-adjustment" class="algoInfoTD">-</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
                    <h2>Beim Wechsel des Tabs wird der Algorithmus abgebrochen.</h2>
                    <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
                </div>
            </div>
			
			
	
        <!-- TAB Beschreibung des Algorithmus -->
        <div id="tab_ti" style="display: none;">
            <div id="ti_div_Einfuehrungstext">

                <h1>Minimum-cost Flows</h1>
                  <div class="BeispielbildContainer"><img id="ti_img_einfuehrung" src="img/graph-editor.svg" alt="Simple graph with 4 nodes."><p><strong>Figure 1.</strong>What's the cheapest way to send maximal amount of flow from s to t?</p></div>
                <p>
                Minimum-cost flow is a classic optimisation problem, which can be motivated by a typical decision problem: Given a transport network of roads, whose usage is restricted by varying capacities and incurs different cost, find the cheapest way to transport the maximal amount of goods from location s to location t.
                </p>
                <p>The corresponding mathematical model is made up of the following information: A directed graph
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>G</mi>
                    <mo stretchy="false">(</mo>
                    <mi>V</mi>
                    <mo>,</mo>
                    <mi>E</mi>
                    <mo stretchy="false">)</mo>
                  </math> modeling the network topology. An upper limit on the capacity of each edge, given by a function <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>.</mo>
                    <mi>e</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math>, and the cost function <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                  </math> which models how expensive it is to send one unit of flow along each edge. The last information required is a start and a goal node.</p>

                <p>The solution to the problem is a flow <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                </math> determining the usage of each edge which minimizes the total cost. The cost incurred by each edge is simply it's flow times the cost of the edge. The solution also has to fulfill some constraints imposed on flows in general - each edge can only carry up to
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>u</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                </math> units of flow, and for all non-terminal nodes in the network the sum of incoming and outgoing flow has to be equal.</p>

                <p>The total amount of flow has to be fixed before optimising for cost. In this application we look at the specific problem of finding the cheapest realisation of the largest possible flow through the network - the min cost max flow problem.</p>
                <p>  </p>
                <p>  </p>

                <h1> Flow network </h1>
                <div class="BeispielbildContainer">
                    <img id="ti_img_flow_network" src="img/maxflow-graph-algorithm-graph.svg"   alt="Network with 4 nodes and max flow."><p><strong>Figure 2.</strong> Flow network <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>N</mi>
                    </math> with calculated maximal flow
                      <math xmlns="http://www.w3.org/1998/Math/MathML">
                        <mi>f</mi>
                      </math> and edge parameters <math xmlns="http://www.w3.org/1998/Math/MathML">
                          <mo stretchy="false">(</mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mo>/</mo>
                          </mrow>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mo>,</mo>
                          <mi>c</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mo stretchy="false">)</mo>
                        </math>.</p>
                </div>

                <p>Let
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>G</mi>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <mi>E</mi>
                  <mo>,</mo>
                  <mi>u</mi>
                  <mo stretchy="false">)</mo>
                </math> be a weighted digraph defined by a set
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>V</mi>
                </math> of
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>n</mi>
                </math> nodes, a set
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>E</mi>
                  <mo>=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mo stretchy="false">|</mo>
                    </mrow>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>V</mi>
                    <mo fence="false" stretchy="false">}</mo>
                  </math> of
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>m</mi>
                </math> directed edges and each edge
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                </math> has a capacity of
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>u</mi>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2265;<!-- ≥ --></mo>
                  <mn>0</mn>
                </math> that denotes the maximal amount of flow that can be send over the edge
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math>. The set of all incoming edges of a node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                </math> is defined as
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mi>w</mi>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>V</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <mo stretchy="false">(</mo>
                  <mi>w</mi>
                  <mo>,</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                  <mo fence="false" stretchy="false">}</mo>
                </math> and the set of all outgoing edges of node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                </math> is
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mi>w</mi>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>V</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                  <mo fence="false" stretchy="false">}</mo>
                </math>. Let also
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                </math> and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                </math> be the number of incoming edges and the number of outgoing edges from node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                </math> respectively.
              </p>
              <p> With this knowledge, one can define a flow network. A flow network
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>N</mi>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <mi>E</mi>
                  <mo>,</mo>
                  <mi>s</mi>
                  <mo>,</mo>
                  <mi>t</mi>
                  <mo>,</mo>
                  <mi>u</mi>
                  <mo stretchy="false">)</mo>
                </math> is a directed graph with a source node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>s</mi>
                </math> and a target node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>t</mi>
                </math>  for which holds
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>s</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>t</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mn>0</mn>
                </math> and a capacity function
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>u</mi>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> for every edge
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                </math>.
                If
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>N</mi>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <mi>E</mi>
                  <mo>,</mo>
                  <mi>s</mi>
                  <mo>,</mo>
                  <mi>t</mi>
                  <mo>,</mo>
                  <mi>u</mi>
                  <mo stretchy="false">)</mo>
                </math>
                is a flow network, then a <strong>flow</strong> in
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>N</mi>
                </math> is a mapping
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>:</mo>
                    <mi>E</mi>
                    <mo stretchy="false">&#x2192;<!-- → --></mo>
                    <mo stretchy="false">[</mo>
                    <mn>0</mn>
                    <mo>,</mo>
                    <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                    <mo stretchy="false">)</mo>
                  </math> that satisfies the following properties:
                  <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2264;<!-- ≤ --></mo>
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>,</mo>
                    <mtext>&#xA0;</mtext>
                    <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
                    <mi>e</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> In words: the amount of flow along an edge can not exceed the capacity of the edge. This condition is called <strong>capacity constraint</strong>. The second condition is that the amount of flow arriving in a node <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>v</mi></math> must be equal to the amount of flow leaving the node <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>v</mi></math>. Or formal:
                  <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>w</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <msup>
                          <mi>N</mi>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mi>i</mi>
                            <mi>n</mi>
                          </mrow>
                        </msup>
                        <mo stretchy="false">(</mo>
                        <mi>v</mi>
                        <mo stretchy="false">)</mo>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>w</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <msup>
                          <mi>N</mi>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mi>o</mi>
                            <mi>u</mi>
                            <mi>t</mi>
                          </mrow>
                        </msup>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>,</mo>
                    <mtext>&#xA0;</mtext>
                    <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
                    <mi>v</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>V</mi>
                    <mtext>&#xA0;\&#xA0;</mtext>
                    <mo fence="false" stretchy="false">{</mo>
                    <mi>s</mi>
                    <mo>,</mo>
                    <mi>t</mi>
                    <mo fence="false" stretchy="false">}</mo>
                  </math>
                    <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/be08.svg" alt="Transformation."><p><strong>Figure 3.</strong> Transformation of parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>1</mn>
                      </msub>
                      <mo>=</mo>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> with equal costs.</p>
                </div>
                  This condition does not apply for the source and sink nodes
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>s</mi>
                  </math> and
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>t</mi>
                  </math>. The incoming flow of
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>s</mi>
                  </math> is equal to the outgoing flow of
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>t</mi>
                  </math> and they both are
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mn>0</mn>
                  </math>.From the second condition follows an important property of the flow, namely the flow leaving from
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>s</mi>
                  </math> must be equal to the flow arriving at
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>t</mi>
                  </math>. Also each node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>V</mi>
                  </math> is associated with an integer number <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math> that represents its supply/demand. If <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&gt;</mo>
                    <mn>0</mn>
                  </math>, node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> is a <strong>supply node</strong>, if <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&lt;</mo>
                    <mn>0</mn>
                  </math>, node  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> is a <strong>demand node</strong> with a demand of <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math>, and if <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>b</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mn>0</mn>
                  </math>, node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> is a <strong>transshipment node </strong>.
                </p>
                <p>
                  Some network flow problems, like the minimum cost flow, also need a cost function <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> which is a mapping <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>:</mo>
                    <mi>E</mi>
                    <mo stretchy="false">&#x2192;<!-- → --></mo>
                    <mo stretchy="false">[</mo>
                    <mo>-</mo>
                    <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                    <mo>,</mo>
                    <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                    <mo stretchy="false">)</mo>
                  </math>, that models how expensive it is to send one unit of flow along each edge. The cost of the flow is calculated as
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>e</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <mi>E</mi>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2217;<!-- ∗ --></mo>
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                  </math>.
                  The structure of the flow network can lead to some inconsistencies which because of the cost can only be avoided with a network tranformation.
                  That is the reason why in this applet some additional conditions are posed. In order for the applet to function correctly, the including of paralell
                  edges is forbiden.
                  Paralell edges are edges that start from the same node and end in the same node, i.e <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>1</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math>.
                
                If there were no costs associated with the edges, one could simply sum the capacities of those edges and combine
                  them in one edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>e</mi>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    </math>.
					
					<div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig4.svg" alt="Transformation."><p><strong>Figure 4.</strong> Transformation of two parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> with different costs.</p>
                </div>
				
                    This transformation can also be valid if the costs of the both edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>1</mn>
                      </msub>
                    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                  </math> are equal which is not always the case, as shown in Figure 3. If the costs of the edges are not equal, one will need to transform the flow network further.
                  If there exist two edges with the same start and end node a new node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>k</mi>
                  </math> is added to the flow network and one of the paralell edges is redirected through this node. That means, that one of the edges
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mi>i</mi>
                    </msub>
                    <mtext>,&#xA0;</mtext>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mo fence="false" stretchy="false">{</mo>
                    <mn>1</mn>
                    <mo>,</mo>
                    <mn>2</mn>
                    <mo fence="false" stretchy="false">}</mo>
                  </math>, lets say <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                  </math>, is replaced by the two new edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>k</mi>
                    <mo stretchy="false">)</mo>
                  </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>k</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost has the same cost and capacity as the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>2</mn>
                      </msub>
                    </math> and the second edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mn>0</mn>
                  </math>, so the transformation does not influence the cost of the flow, and capacity <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                    <mo stretchy="false">)</mo>
                  </math>. This transformation is grafically shown in Figure 4.
                </p>
                <p> Another notational problem are the opposite edges. Two edges are opposite, if the start node of the first edge is the same as the end node of the second
                  edge and the end node of the first edge is the same as the start node of the second one, or formal <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math>. If the costs of the both edges are equal, the transformation is easy. One can remove the edge with the smaller capacity by substracting it from the
              capacity of the other edge, as shown in Figure 5. If the costs are not equal, both edges have to remain in some form in the flow network. This can be
              achieved with the same transformation as for the parallel edges with different costs from above, which is also shown for opposite edges in Figure 6.

              <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig5.svg" alt="Transformation."><p><strong>Figure 5.</strong>Transformation of opposite edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>e</mi>
                <mn>2</mn>
              </msub>
              <mo>=</mo>
              <mo stretchy="false">(</mo>
              <mi>v</mi>
              <mo>,</mo>
              <mi>w</mi>
              <mo stretchy="false">)</mo>
            </math> with equal costs.</p>
          </div>

<!--    -->

                <h1>Residual network </h1>
                <p> In order to work with flows, one often makes use of residual networks, for example to find the maximal flow or to calculate the minimal cost for a flow in a network. The concept of residual networks is based on the following intuitive idea. If edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> carries <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> units of flow, then one can send additional <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> units of flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>w</mi>
                  </math> along the edge   <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                  </math>. One can also cancel (some of) the existing flow on the edge   <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </math> sending up to <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math> units of flow from mode <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> to node </math> units of flow from mode <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math>. While sending a unit of flow frome node </math> units of flow from mode <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math> to node </math> units of flow from mode <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> over the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </math> increases the flow cost by <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>c</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math> units, sending flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math> decreases the flow cost by <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>c</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math> units.
                </p>
                <p>
                  By using this ideas, one defines the residual network <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>N</mi>
                      <mi>f</mi>
                    </msub>
                  </math>
                   with respect to a given flow <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>f</mi>
                  </math> as follows:
                  <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig6.svg" alt="Transformation."><p><strong>Figure 6.</strong>Transformation of two opposite edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> with different costs.</p>
				</div>
                   Each edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> in the original network (see Figure 7.) is replaced by two new edges
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math>: the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and resifual capacity
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and the edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and residual capacity <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> (see Fig.4). The residual network conists only of edges with positive residual capacity, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&gt;</mo>
                    <mn>0</mn>
                    <mtext>,&#xA0;</mtext>
                    <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <msub>
                      <mi>E</mi>
                      <mi>f</mi>
                    </msub>
                  </math>
                </p>
                To summarize, a residual network is defined as <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>N</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>:=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <msub>
                    <mi>E</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>s</mi>
                  <mo>,</mo>
                  <mi>t</mi>
                  <mo>,</mo>
                  <msub>
                    <mi>u</mi>
                    <mi>f</mi>
                  </msub>
                  <mo stretchy="false">)</mo>
                </math>, with
                <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <msub>
                    <mi>u</mi>
                    <mi>f</mi>
                  </msub>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow>
                    <mo>{</mo>
                    <mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false">
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&#x2212;<!-- − --></mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&gt;</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>+</mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>w</mi>
                          <mo>,</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>w</mi>
                          <mo>,</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&gt;</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, otherwise</mtext>
                        </mtd>
                      </mtr>
                    </mtable>
                    <mo fence="true" stretchy="true" symmetric="true"></mo>
                  </mrow>
                </math> and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>E</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msub>
                    <mi>c</mi>
                    <mi>f</mi>
                  </msub>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&gt;</mo>
                  <mn>0</mn>
                  <mo fence="false" stretchy="false">}</mo>
                </math>

              </p>

              <p>
                 <math xmlns="http://www.w3.org/1998/Math/MathML">

                            <mtext>&#xA0;</mtext>

                          </math>     </p>
				<div class="BeispielbildContainer"><img id="ti_img_res3" src="img/res2.svg" alt="Residual network of the original network."><p><strong>Figure 7.</strong> An edge <math>
                        <mi> e </mi>
                      </math> in a flow network, with flow, capacity, and cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                        <mo stretchy="false">(</mo>
                        <mi>f</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mrow class="MJX-TeXAtom-ORD">
                          <mo>/</mo>
                        </mrow>
                        <mi>u</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mo>,</mo>
                        <mi>c</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mo stretchy="false">)</mo>
                      </math></p>
				</div>

              <p> However, the concept of residual networks can create some notatinal difficulties. This happens when the flow network contains both edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
                </math>
                and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math> then the residual network can contain two parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> or <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math> with different cots and residual capacities. If this happens, the edge
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> will no longer define a unique edge cost and residual capacity. That is why one assumes, without los of generality, that for every node pair <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>v</mi>
                <mtext>&#xA0;and&#xA0;</mtext>
                <mi>w</mi>
              </math> the flow network <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>N</mi>
              </math> contains only one of the edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math>
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math>, then the residual network will not contain parallel edges.
            </p>

            <h1>Min-cost flow problem </h1>  
            <p>
              Let <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>N</mi>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>V</mi>
                <mo>,</mo>
                <mi>E</mi>
                <mo>,</mo>
                <mi>s</mi>
                <mo>,</mo>
                <mi>t</mi>
                <mo>,</mo>
                <mi>u</mi>
                <mo stretchy="false">)</mo>
              </math> be a flow network,
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>c</mi>
                <mo>:</mo>
                <mi>E</mi>
                <mo stretchy="false">&#x2192;<!-- → --></mo>
                <mo stretchy="false">[</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                <mo stretchy="false">)</mo>
              </math> a cost function and <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>d</mi>
                <mo>&#x2265;<!-- ≥ --></mo>
                <mn>0</mn>
              </math> the required flow amount. The problem "find a flow
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                </math> with <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                  <mi>a</mi>
                  <mi>l</mi>
                  <mo stretchy="false">(</mo>
                  <mi>f</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>d</mi>
                </math> in <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                  <mi>a</mi>
                  <mi>l</mi>
                  <mo stretchy="false">(</mo>
                  <mi>f</mi>
                  <mo stretchy="false">)</mo>
                </math> is the amount of flow in <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                </math>, such that
				
				<div class="BeispielbildContainer"><img id="ti_img_res3" src="img/res2.svg" alt="Transformation of an edge in residual network."><p><strong>Figure 8.</strong>
				The edge <math xmlns="http://www.w3.org/1998/Math/MathML">
				<mi>e</mi>
				</math> from Figure 7.</p>
				</div>
				
                <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <munder>
                    <mo>&#x2211;<!-- ∑ --></mo>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>e</mi>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </mrow>
                  </munder>
                  <mi>c</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x22C5;<!-- ⋅ --></mo>
                  <mi>f</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>m</mi>
                  <mi>i</mi>
                  <mi>n</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo maxsize="2.047em" minsize="2.047em">{</mo>
                  </mrow>
                  <munder>
                    <mo>&#x2211;<!-- ∑ --></mo>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>e</mi>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </mrow>
                  </munder>
                  <mi>c</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x22C5;<!-- ⋅ --></mo>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mtext>&#xA0;is flow in&#xA0;</mtext>
                  <mi>N</mi>
                  <mtext>&#xA0;with&#xA0;</mtext>
                  <mi>v</mi>
                  <mi>a</mi>
                  <mi>l</mi>
                  <mo stretchy="false">(</mo>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>d</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo maxsize="2.047em" minsize="2.047em">}</mo>
                  </mrow>
                  <mo>"</mo>
                </math>
				
                is called <strong>minimum cost flow problem</strong>. A feasible flow <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                </math> is an optimal solution of the minimum cost flow problem if and only if the residual network <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>N</mi>
                    <mi>f</mi>
                  </msub>
                </math> contains no negative cost cycle. This condition is called <strong>negative cycle optimality condition</strong>.
            </p>

            <p>This applet uses the max-flow as <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>d</mi>
            </math>, i.e. it solves the <strong>min-cost-max-flow problem</strong>. </p>

                <h1>Idea of the Cycle Cancelling Algorithm</h1>
				<div class="BeispielbildContainer"><img id="ti_img_res3" src="img/res3.svg" alt="Residual network of the original network."><p><strong>Figure 9.</strong> The residual network corresponding to the network flow <math xmlns="http://www.w3.org/1998/Math/MathML">
					<mi>N</mi>
				  </math> in Figure 2.</p>
				</div>


                <p>The cycle-cancelling algorithm is based on the negative cost cycle optimality condition and it takes an iterative approach, starting with any feasible flow with the desired magnitude (e.g. feasible flow can be obtained with a max-flow algorithm). The algorithm maintains a feasible flow
                    <math xmlns="http://www.w3.org/1998/Math/MathML"> <mi>f</mi></math> and at every iteration attempts to reduce the cost by moving some of the flow to cheaper edges without violating the flow coonstraints. The algorithm first finds a maximum flow without considering the costs, using the Edmonds-Karp implementation of the Ford-Fulkerson method.
                    Basically Edmonds-Karp algorithm starts with a flow of
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                      <mo>=</mo>
                      <mn>0</mn>
                    </math>, then it builds the residual network
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>N</mi>
                        <mi>f</mi>
                      </msub>
                    </math>, ignoring the costs, and finds the shortest path
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>P</mi>
                    </math>
                     from the source node
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>s</mi>
                    </math>
                     to the target node
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>t</mi>
                    </math>
                     and augments
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>g</mi>
                      <mo>=</mo>
                      <mi>m</mi>
                      <mi>i</mi>
                      <mi>n</mi>
                      <mo fence="false" stretchy="false">{</mo>
                      <mi>r</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mo stretchy="false">|</mo>
                      </mrow>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>P</mi>
                      <mo fence="false" stretchy="false">}</mo>
                    </math>
                     units of flow along
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>P</mi>
                    </math>
                    , to saturate the edge
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>P</mi>
                    </math>
                     with the minimal capacity. Then updates the current flow
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                      <mo>=</mo>
                      <mi>f</mi>
                      <mo>&#x2295;<!-- ⊕ --></mo>
                      <mi>g</mi>
                    </math>. The algorithm repeats these steps until there is no path
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>P</mi>
                    </math> in the residual network
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>N</mi>
                        <mi>f</mi>
                      </msub>
                    </math>. For more details see <a href = "https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html">Ford-Fulkerson</a>.</p>
                    After the maximal flow
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                    </math> has been found, the algorithm builds the residual network
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>N</mi>
                        <mi>f</mi>
                      </msub>
                    </math> associated with the flow
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                    </math>, taking the costs into account as described above. Then the algorithm starts searching for a negative cycle
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>W</mi>
                    </math> in
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>N</mi>
                        <mi>f</mi>
                      </msub>
                    </math>. Sending flow along a cycle in the residual graph always leads to another valid flow and keeps the total flow constant.
                    If the sum of the costs for the edges in the cycle is negative, changing the flow will reduce the overall cost and improve the solution.
                    The <a href = "https://www-m9.ma.tum.de/graph-algorithms/spp-bellman-ford/index_en.html">Bellman-Ford algorithm</a> is used for finding
                    negative cycles. Bellman-Ford algorithm finds the shortest path from
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>s</mi>
                    </math>
                     to
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>t</mi>
                    </math>
                     in a graph after
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>n</mi>
                      <mo>&#x2212;<!-- − --></mo>
                      <mn>1</mn>
                    </math> phases, where
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>n</mi>
                    </math>
                     is the number of nodes in the graph
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>n</mi>
                      <mo>=</mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mo stretchy="false">|</mo>
                      </mrow>
                      <mi>V</mi>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mo stretchy="false">|</mo>
                      </mrow>
                    </math>
                     and a phase is "looking once at all edges of the graph and updating the costs of the nodes". If after iterating all phases, the algorithm can still shorten the shortest path, then there is a negative cycle
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>W</mi>
                    </math> in the graph. The edges and the nodes of which the cycle is composed can be found by going back from the target node
                    <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>t</mi>
                    </math> until a cycle is traversed.
                  </p>

				  <div class="BeispielbildContainer"><img id="ti_img_neg_cycle" src="img/neg_cycle.svg" alt="Negative cycle in residual network."><p><strong>Figure 10.</strong> A negative cost cycle <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mo stretchy="false">[</mo>
                  <mi>t</mi>
                  <mo stretchy="false">&#x2192;<!-- → --></mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="false">&#x2192;<!-- → --></mo>
                  <mn>2</mn>
                  <mo>,</mo>
                  <mn>2</mn>
                  <mo stretchy="false">&#x2192;<!-- → --></mo>
                  <mi>t</mi>
                  <mo stretchy="false">]</mo>
                </math> found with the Bellamn-Ford algorithm in the residual network in Figure 9. </p>
				</div>
				  
                <p>
                    After identifying a negative cost cycle in the residual network (Figure 10.), the algorithm redirects <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>&#x03B4;<!-- δ --></mi>
                      <mo>:=</mo>
                      <mi>m</mi>
                      <mi>i</mi>
                      <mi>n</mi>
                      <mo fence="false" stretchy="false">{</mo>
                      <mi>r</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mo stretchy="false">|</mo>
                      </mrow>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>W</mi>
                      <mo fence="false" stretchy="false">}</mo>
                    </math>
                    units of flow along the cycle <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math>  in the graph. The edges and
                    the nodes, of which the cycle <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>W</mi>
                    </math> is composed, can be found by going back from the target node and saturates the edge with the lowest residual
                    capaciy. This removes the edge from the residual network, therby removing the negative cost cycle <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>W</mi></math>. Since the new residual network might still contain other negative cost cycles, the algorithm iterates by running
                    the Bellman-Ford algorithm again. When the residual network contains no more negative cost cycles, the algorithm has found the minimum
                    cost flow and terminates.
                </p>

                <h1>What now?</h1>
				<br style="clear: both;" />
                <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                    <h3>Create a graph and play through the algorithm</h3>
                    <button id="ti_button_gotoDrawGraph">Try algorithm after creating a graph</button>
                    <button id="ti_button_gotoAlgorithm">Try algorithm on an example graph</button>
                </div>
                <!--<br style="clear: both;" />-->
				<div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                    <h3>Test your knowledge in the exercises</h3>
                    <button id="ti_button_gotoExerciseResidualNetwork">Exercise: Residual network </button><br>
                    <button id="ti_button_gotoExercise1">Exercise: Min-Cost-Flow</button>
                </div>
                <br style="clear: both;" />
            </div>
		</div>



        <!-- Tab exercise 1 -->
        <div id="tab_tf1" >
            <div>
                <div class="canvasWrapper">
                    <div class="svgContainer">
                    <svg class="graphCanvas" id="tf1_canvas_graph" width="700" height="450"></svg>
                    </div>
                    <a class="svgDownloader" download="graph-algorithm.svg" href="data:text/plain,test">SVG Download</a>

                    <!-- Legende maximized-->

                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>Node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-st.svg" alt="nodes" class="LegendeIcon"></td>
                                    <td><span>Source node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-t.svg" alt="nodet" class="LegendeIcon"></td>
                                    <td><span>Target node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge in residual graph, cost 1</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-cycle.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge on negative cycle, cost 1</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <!-- Legende minimized -->
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>

                </div>
                <!-- rechter Teil -->

                <div id="tf1_div_statusWindow" class="statusWindow">
                   <center> <h2  id= "f1-start" class="">Choose a graph and try to answer the questions while running the algorithm!</h2>
					<h2 id = "f1_started"> Answer the questions while running the algorithm!</h2></center>
                   
					<!--<select name="graphSelector" id="tf1_graphSelector">
					<option selected = true label="graph1">graph1</option>
					<option label="graph2">graph2</option>
					<option label="graph3">graph3</option>						
					<option label="graph4">graph4</option>
					<option label="graph5">graph5</option>
					<option label="graph6">graph6</option>
					<option label="graph7">graph7</option>
					<option label="graph8">graph8</option>
					<option label="graph9">graph9</option>
					</select>-->

              <br>

              <button id="tf1_button_start">Start Exercise</button> 
                    <div id="tf1_div_abspielbuttons">
						<input  id="tf1_button_rewind" type="checkbox"><label for="tf1_button_rewind" id="tf1_button_text_rewind">rewind</label>
						
                        <button id="tf1_button_1Schritt">Next Step</button>

                        <input  id="tf1_button_vorspulen" type="checkbox"><label for="tf1_button_vorspulen" id="tf1_button_text_fastforward">Forward: Next question</label>

                        <span id="tf1_button_text_pause" style="display:none">Pause</span>
                    </div>
                    <div id="tf1_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
                    </div>
                    <div id="tf1_div_statusTabs">
                         <ul>
                            <li><a href="#tf1_div_statusErklaerung">Explanation</a></li>
                            <li><a href="#tf1_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <!-- Status Erklärung -->
                        <div id="tf1_div_statusErklaerung">
                        </div>

                        <!-- Tab Pseudocode-->
                        <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
							<div id="fr-pseudocode-select-source">
								<p>s &larr; pick(v)</p>
							</div>
							<div id="fr-pseudocode-select-target">
								<p>t &larr; pick(v)</p>
							</div>
							<div id="fr-pseudocode-start-algorithm">
								<p><strong>BEGIN</strong></p>
								<p>| </p>
							</div>
							<div id="pseudocode-get-max-flow">
                                <p>|  (* Initialize max flow *)</p>
                                <p>|  CALCULATE MAX FLOW <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mi>f</mi>
                                    <mo stretchy="false">(</mo>
                                    <mi>s</mi>
                                    <mo>,</mo>
                                    <mi>t</mi>
                                    <mo stretchy="false">)</mo>
                                  </math> IN THE NETWORK </p>
                                   <p>|  USING THE FORD-FULKERSON ALGORITHM</p>
                                   <p>|  </p>
                            </div>
							<div id="fr-pseudocode-main-loop">
								<p>|  (* Main Loop *)</p>
								<p>|  <strong> WHILE</strong> (the residual network <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>G</mi><mi>f</mi></msub></math></p>
								<p>|   |       contans a negative cycle) <strong>DO</strong></p>
								<p>|   |</p>
							</div>
							<div id="fr-pseudocode-find-neg-cycle">
								<p>|   |  EXECUTE BELLMAN-FORD ALGORITHM TO</p>
								<p>|   |  IDENTIFY A NEGATIVE CYCLE <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math>;</p>
								<p>|   |   <strong>IF</strong> (negative cycle exists)<strong>THEN</strong></p>
								<p>|   |   |   IDENTIFY cycle-edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>&#x2208;<!-- ∈ --></mo>
                                  <mi>W</mi>
                                </math>                                 </p>
								<p>|   |   |   <math xmlns="http://www.w3.org/1998/Math/MathML">
                                <mi>&#x03B4;<!-- δ --></mi>
                                <mo>:=</mo>
                                <mi>m</mi>
                                <mi>i</mi>
                                <mi>n</mi>
                                <mo fence="false" stretchy="false">{</mo>
                                  <mi>r</mi>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>:</mo>
                                  <mo stretchy="false">(</mo>
                                  <mi>v</mi>
                                  <mo>,</mo>
                                  <mi>w</mi>
                                  <mo stretchy="false">)</mo>
                                  <mo>&#x2208;<!-- ∈ --></mo>
                                  <mi>W</mi>
                                  <mo fence="false" stretchy="false">}</mo>
                                </math></p>
                                <p>|   |   <strong>ENDIF</strong> </p>
							</div>
							<div id="fr-pseudocode-adjust-cycle">
								<p>|   |   <strong>FOR</strong> (<math xmlns="http://www.w3.org/1998/Math/MathML">
                                <mo stretchy="false">(</mo>
                                <mi>v</mi>
                                <mo>,</mo>
                                <mi>w</mi>
                                <mo stretchy="false">)</mo>
                                <mo>&#x2208;<!-- ∈ --></mo>
                                <mi>W</mi>
                              </math></p>
                              <p>|   |   |  <math xmlns="http://www.w3.org/1998/Math/MathML">
                                <mi>f</mi>
                                <mo stretchy="false">(</mo>
                                <mi>v</mi>
                                <mo>,</mo>
                                <mi>w</mi>
                                <mo stretchy="false">)</mo>
                                <mo>=</mo>
                                <mi>f</mi>
                                <mo stretchy="false">(</mo>
                                <mi>v</mi>
                                <mo>,</mo>
                                <mi>w</mi>
                                <mo stretchy="false">)</mo>
                                <mo>+</mo>
                                <mi>&#x03B4;<!-- δ --></mi>
                              </math> </p>
                              <p>|   |   <strong>ENDFOR</strong> </p>
                              <p>|   |</p>
                              <p>|  <strong>ENDWHILE</strong></p>
                              <p>|</p>
							</div>
							<div id="fr-pseudocode-finished">
								<p><strong>END</strong></p>
							</div>
                        </div>
					</div>
                </div>
            </div>
           
            <div id="tf1_div_TabIntroDialog" title="Exercise 1" class="tabIntroDialog">
                <h2>In this part you can test your knowledge: What would the algorithm do?</h2>
                <p>
                    The algorithm will be executed normally, but will stop in a few places. Then you will have to predict, what the algorithm would do next.
                </p>
                <p>Hint: Recall the description of the algorithm.</p>
            </div>
            <div id="tf1_div_confirmTabChange" title="Terminate the algorithm?" class="tabChangeWarningDialog">
                <h2>If you switch tabs, the execution will be terminated.</h2>
                <p>You can open <a href="#" target="_blank" tabindex="-1">another browser window</a> to read the description in parallel.</p>
            </div>
        </div>
		
		
		
		
		<div id="tab_tf2">

			<div>
	<!--  Graph auf linker Seite -->
				<div class="canvasWrapper">
					<div class="svgContainer">
						<svg class="graphCanvas" id="tf2_canvas_graph" width="700" height="450"></svg>
					</div>

					<a class="svgDownloader" download="graph-algorithm.svg" href="data:text/plain,test">SVG Download</a>


	<!--Graph informationen: Graph anzeigen-->
					<div id="f2-graph-info">
						<span id="f2-graph-state"> </span>
					</div>

					<div id="f2-graph-flow">
						<span id="f2-flow-st"> </span>
					</div>

    <!-- Legende maximized-->
					<div class="Legende">
						<h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>

						<div class="LegendeText">
							<table>
								<tr>
									<td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
									<td><span>Knoten</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-st.svg" alt="node" class="LegendeIcon"></td>
									<td><span>S/T Knoten</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>Kante mit Kapazität 10 und Fluss 7.</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>Kante im Residualgraphen.</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-augmenting.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>Kante auf augmentierendem Pfad.</span></td>
								</tr>
							</table>
						</div>
					</div>

       <!-- Legende minimized -->
					<div class="LegendeMinimized">
						<h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
					</div>


				</div>

    <!-- rechter Teil -->
				<div id="tf2_div_statusWindow" class="statusWindow">
					<h2 class="">Build the corresponding residual netwprk!</h2>
	
				<div id="tf2_div_abspielbuttons">
           <!--  <input  id="tf2_button_rewind" type="checkbox"><label for="tf2_button_rewind" id="tf2_button_text_rewind">rewind</label> -->

					<button id="tf2_button_1Schritt">Next Network</button>

            <!--  <input  id="tf2_button_vorspulen" type="checkbox"><label for="tf2_button_vorspulen" id="tf2_button_text_fastforward">Zur nächsten Frage vorspulen</label> -->

            <!--  <span id="tf2_button_text_pause" style="display:none">Pause</span> -->
				</div>

				<div id="tf2_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
				</div>

				<div id="tf2_div_statusTabs">
					<ul>
						<li><a href="#tf2_div_statusErklaerung">Explanation</a></li>
                <!--<li><a href="#tf2_div_statusPseudocode">Pseudocode</a></li> -->
					</ul>

				<div id="tf2_div_statusErklaerung">
					<p>In the following exercise you will get different networks \(N\) with the respective capacities, flow values and costs \(u(e)\), \(f(e)\) and \(c(e)\) for all edges \(e \in E\), based on a current flow \(f\).</p>
					<p> Your task is to fill the missing residual capacities \(r(e')\) bzw. \(r(e'')\) of the out- and  ingoing edges \(e'\) und \(e''\) in the corresponding residual network
                <math>
                  <msub>
                    <mi>N</mi>
                    <mi>f</mi>
                 </msub>
                </math>.</p>

              <br>

              <center>
              <h2 id= "f2-start"> Choose a number of networks for the exercise:</h2>

              <select name="graphSelector" id="tf2_Selector">
                <option selected = true label="3">3</option>
                <option label="4">4</option>
                <option label="5">5</option>
                <option label="6">6</option>
                <option label="7">7</option>
                <option label="8">8</option>
				<option label="9">9</option>
                </select>

              <br>
              <p> </p>

              <button id="tf2_button_start">Klick here to start!</button> </center>
                <!-- <img id="tf2_img_1" src="img/Bes/ex01.svg" alt="Suche" width="250"/> -->

            </div>




            <!-- Tab Pseudocode
            <div class="PseudocodeWrapper" id="tf2_div_statusPseudocode">

            </div>
            -->


			</div>
		</div>
	</div>

  <div id="tf2_div_TabIntroDialog" title="Exercise 2" class="tabIntroDialog">

                <h2>In this part you can practice the construction of residual networks!</h2>
                <p>
                    You will get a network with current flow. Your task is to fill out the missing residual capacities and costs in the residual network!
                </p>
				
                <p><strong>Tip:</strong> Before you start read the information on residual networks again.</p>
				<p><strong> WARNING! </p></strong>
				<p> You can set the missing residual capacities and costs only once. When a value is set it can not be changed any more. </p>
                <p>Good Luck!</p>
            </div>
            <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">

				<h2>If you switch tabs, the execution will be terminated.</h2>
                <p>You can open <a href="#" target="_blank" tabindex="-1">another browser window</a> to read another tab in parallel.</p>
            </div>

		</div>		
            
			
			<!-- TAB Weiteres -->
            <div id="tab_tw" style="display: none;">
                <div id="tw_Accordion">
                    <h3>Wie sieht der (Pseudo-)Code des Algorithmus aus?</h3>
                    <div>
                        <pre><code>Input: gerichteter Graph G=(V,E), Kapazitätsfunktion u(e), Kostenfunktion c(e), Quelle und Senke
Output: Min-Cost Max-Flow f(e)</code></pre>
                        <hr>
                        <pre>
<code>BEGIN
  (* Initialisiere max. Fluss *)
  f = BERECHNE MAX FLOW()
  (* Main Loop *)
  WHILE negativer Kreis evtl. vorhanden DO
    KONSTRUIERE RESIDUALGRAPH G'(V,E') MIT KAPAZITÄTEN u'(e)
    FÜHRE BELLMAN-FORD AUF G' VON SENKE AUS
    IF negativer Kreis gefunden
      IDENTIFIZERE Kreiskanten
      Anpassung &larr; min(u'(e) | e &isin; Kreiskanten )
      FOR e &isin; Kreiskanten
        f(e) += Anpassung
END
</code></pre>
                    </div>
                    <h3>Wie schnell ist der Algorithmus?</h3>
                    <div>
                        <p>Der allgemeine Cycle Cancelling Algorithmus hat eine nicht-polynomielle Laufzeit von O(|E| |V| C), wobei C die Kosten des initialen Flusses angibt - da jede Iteration eine Ausführung von Bellman-Ford in O(|E| |V|) erfordert und die Kosten um mindestens 1 reduziert.</p>
                        <p>Es gibt verschiedene Varianten des Algorithmus für das Min-Cost Flow Problem, welche bessere Laufzeiten erreichen. Eine Anpassung des Cycle Cancelling Algorithmus ist der <strong>minimum mean Cycle Cancelling Algorithmus</strong>, welcher dann bereits streng polynomiell ist. Andere Algorithmen findet man beispielsweise <a href="https://en.wikipedia.org/wiki/Minimum-cost_flow_problem#Solutions">hier</a>.</p>
                    </div>
                    <h3>Literatur</h3>
                    <div>
                        <h4>Veröffentlichungen</h4>
                        <dl>
                        <dt>[GT89]</dt>
                        <dd> Andrew V. Goldberg and Robert E. Tarjan (1989). "Finding minimum-cost circulations by canceling negative cycles". Journal of the ACM. 36 (4): 873–886. doi:<a href="https://dx.doi.org/10.1145%2F76359.76368">10.1145/76359.76368</a>.</dd>
                        <dl>
                        <h4>Webseiten</h4>
                        <ol>
                            <li><a href="https://en.wikipedia.org/wiki/Minimum-cost_flow_problem">Wikipedia: Minimum-cost flow problem</a></li>
                            <li><a href="http://www.columbia.edu/~cs2035/courses/ieor6614.S16/mcf.pdf">Minimum Cost Flows</a></li>
                        </ol>
                    </div>
                    <h3>Wo finde ich noch mehr Informationen zu Graphalgorithmen?</h3>
                    <div>
                        <p>
                            Weitere Graphalgorithmen werden auf der <a href="http://www-m9.ma.tum.de/Allgemeines/Routenplanung">Webseite des Lehrstuhls M9</a> der TU München erklärt.
                        </p>
                        <p>
                            Außerdem gibt es ein interessantes Buch zu kürzesten Wegen: <a href="http://www-m9.ma.tum.de/Ruth/WebHome">Das Geheimnis des kürzesten Weges</a>
                        </p>
                        <p>
                            Ein <a href="http://www.ma.tum.de/Studium/Studieninteressierte"> Mathematikstudium an der TU München</a> beantwortet alle Fragen zur Graphentheorie (falls eine Lösung bekannt ist).
                        </p>
                    </div>
                    <h3>Ein letzter Hinweis zum Ziel dieser Seite und zu Zitationen</h3>
                    <div>
                        <p>Der Lehrstuhl M9 der TU München beschäftigt sich mit diskreter Mathematik, angewandter Geometrie und der Optimierung von mathematischen Problemen. Die hier dargestellten Algorithmen sind sehr grundlegende Beispiele für Verfahren der diskreten Mathematik (die tägliche Forschung des Lehrstuhl geht weit darüber hinaus). Diese Seite soll SchülerInnen und Studierenden dabei helfen, diese auch im realen Leben sehr wichtigen Verfahren (besser) zu verstehen und durch Ausprobieren zu durchdringen.</p>
                        <p>Um diese Seite zu zitieren, nutze bitte die folgenden Angaben:</p>
                        <ul>
                            <li>Titel: Der Cycle Cancelling Algorithmus
                            <li>Autoren: Quirin Fischer, Wolfgang F. Riedl; Technische Universität München
                            <li>Link: <a href="https://www-m9.ma.tum.de/graph-algorithms/flow-cycle-cancelling">https://www-m9.ma.tum.de/graph-algorithms/flow-cycle-cancelling</a>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <p class="Disclaimer">
                IDP Projekt von Quirin Fischer und Gergana Kratuncheva am Lehrstuhl M9 der Technischen Universität München. 2017 | <a href="index_en.html">EN</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Disclaimer und Rechtshinweise</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">Impressum</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Anregungen</a>
            </p>
        </footer>
    </body>